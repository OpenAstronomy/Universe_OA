<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy</title><link>http://openastronomy.org/Universe_OA/</link><description>This is an aggregator of openastronomy people</description><atom:link href="http://openastronomy.org/Universe_OA/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 01 Jul 2025 02:21:43 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Things Are Starting to Come Together</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250629_1859_darshvn/</link><dc:creator>Darshan Patil</dc:creator><description>&lt;p&gt;The past couple of weeks have been really productive. After the initial planning and community bonding period, I’ve finally started working on the actual implementation. The transition from understanding the theory to getting hands-on with the code has been challenging but rewarding.&lt;/p&gt;
&lt;p&gt;After writing my last blog post and going through the codebase more thoroughly, I discovered there are several existing classes and methods that can be reused for this project. This has led to a revised approach that builds on what’s already working well in RADIS.&lt;/p&gt;
&lt;h4&gt;Revised Approach&lt;/h4&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/876/1*XSL9jIwlwb7FZpoD5oZjEg.png"&gt;&lt;/figure&gt;&lt;p&gt;The core approach is the same as originally planned, but now the rovibrational populations are calculated using the existing RovibParFuncCalculator. This lets me reuse code while adding the electronic state functionality we need.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;The workflow starts with user inputs: electronic temperature (Telec), rotational temperature (Trot), and optional manual band scaling. The system processes the main electronic states OH(X) and OH(A) for now only works with hydroxyl radical calculations.&lt;/p&gt;
&lt;p&gt;The ElectronicPartitionFunction computes population fractions for each electronic state at the specified electronic temperature. Meanwhile, the RovibParFuncCalculator handles rovibrational populations for each state at the rotational temperature. These calculations run in parallel, and their results get multiplied to determine total populations for each rovibrational level within each electronic state.&lt;/p&gt;
&lt;p&gt;After applying any manual band scaling factors, all contributions from the various electronic states are summed to build the complete spectrum.&lt;/p&gt;
&lt;h4&gt;The Mathematical Foundation&lt;/h4&gt;&lt;p&gt;The calculation relies on determining the total population of a rovibrational level using:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/991/1*95PzSSkP9W6DyHOTonDx4A.png"&gt;&lt;/figure&gt;&lt;p&gt;This separates cleanly into electronic and rovibrational components. The electronic part depends on degeneracy and energy at the electronic temperature, while the rovibrational part accounts for vibrational and rotational contributions at the rovibrational temperature.&lt;/p&gt;
&lt;p&gt;The partition functions are calculated separately: Z_elec for electronic states and Z_rovib for rovibrational states. For practical purposes, these can be treated as separable components, which simplifies the implementation considerably.&lt;/p&gt;
&lt;h4&gt;Working with ExoMol Data&lt;/h4&gt;&lt;p&gt;Working with ExoMol’s .states files has been interesting. These files contain detailed molecular energy level information, but parsing them correctly for electronic transitions requires careful attention to the quantum mechanics involved.&lt;/p&gt;
&lt;p&gt;We’ve adapted the existing read_states functionality in RADIS to handle all the columns we need for this project. The standard format includes columns for [n, E, g, J, e/f, v, F1/F2, State], where each parameter is important for determining molecular behavior. By extending the existing parsing capabilities, we can now properly extract and interpret these electronic quantum numbers for use in subsequent calculations.&lt;/p&gt;
&lt;h4&gt;Electronic State Mapping&lt;/h4&gt;&lt;p&gt;I’ve implemented functions to map electronic states and calculate proper degeneracies, which are essential for accurate partition function calculations. This mapping system ensures each quantum state is properly characterized with its corresponding statistical weight and energy.&lt;/p&gt;
&lt;p&gt;The mapping process involves parsing quantum state labels from ExoMol files and translating them into RADIS’s internal representation. This maintains the physical meaning while adapting to RADIS’s computational framework.&lt;/p&gt;
&lt;h4&gt;Architecture Design&lt;/h4&gt;&lt;p&gt;One of the more interesting technical challenges has been designing the partition function architecture for electronic states. I’ve been working with the existing RovibParFuncCalculator in radis/levels/partfunc.py, which handles rovibrational partition functions effectively.&lt;/p&gt;
&lt;p&gt;The architecture centers on separating electronic partition function calculations into dedicated components while maintaining integration with existing functionality. The ElectronicPartitionFunction class handles electronic state calculations, managing the quantum mechanical relationships and temperature dependencies for electronic population distributions.&lt;/p&gt;
&lt;p&gt;This integrates with existing rovibrational calculations and allows users to specify different electronic temperatures (Telec) independently from rovibrational temperatures. This separation makes physical sense since electronic excitation often occurs under different conditions than rovibrational excitation.&lt;/p&gt;
&lt;p&gt;The system also includes manual band intensity adjustment capabilities, giving researchers flexibility to fine-tune calculations based on experimental observations or theoretical corrections that might not be fully captured in the base calculations.&lt;/p&gt;
&lt;h4&gt;Current Implementation Status&lt;/h4&gt;&lt;p&gt;The implementation is progressing well. ExoMol parsing now properly handles electronic state information, and band scaling functionality works with dictionary-based input formats.&lt;/p&gt;
&lt;p&gt;The ElectronicPartitionFunction class computes population fractions for individual electronic states at specified temperatures. The enhanced RovibParFuncCalculator handles rovibrational populations across multiple electronic states. Integration multiplies electronic fractions by rovibrational populations to get total level populations, and final spectrum synthesis sums contributions from all electronic states.&lt;/p&gt;
&lt;h4&gt;Next Steps&lt;/h4&gt;&lt;p&gt;The next phase will focus on fixing the broken control and data flow, optimization, testing with various molecular systems, and ensuring robust performance across the range of conditions RADIS users encounter.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=388f0918afc5" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250629_1859_darshvn/</guid><pubDate>Sun, 29 Jun 2025 17:59:01 GMT</pubDate></item><item><title>✨Good Time, Bad Time: GTI/BTI :)</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250629_0626_kashish2210/</link><dc:creator>kashish shrivastav</dc:creator><description>&lt;p&gt;In my continued journey with &lt;code&gt;Stingray.jl&lt;/code&gt; During GSoC 2025, this phase focused on a core aspect of high-energy astrophysics: time filtering using &lt;strong&gt;GTIs (Good Time Intervals)&lt;/strong&gt; and &lt;strong&gt;BTIs (Bad Time Intervals)&lt;/strong&gt;. After a productive discussion with my mentor &lt;a class="" href="https://github.com/matteobachetti" rel="noopener" target="_new"&gt;@matteobachetti&lt;/a&gt; during our meet, I dove into implementing and refining functionality around GTIs—an essential tool in the timing analysis of astrophysical data.&lt;/p&gt;&lt;div class="flex basis-auto flex-col -mb-(--composer-overlap-px) [--composer-overlap-px:24px] grow overflow-hidden"&gt;&lt;div class="relative h-full"&gt;&lt;div class="flex h-full flex-col overflow-y-auto [scrollbar-gutter:stable_both-edges] @[84rem]/thread:pt-(--header-height)"&gt;&lt;div class="@thread-xl/thread:pt-header-height flex flex-col text-sm pb-25"&gt;&lt;article class="text-token-text-primary w-full" dir="auto"&gt;&lt;div class="text-base my-auto mx-auto py-5 [--thread-content-margin:--spacing(4)] @[37rem]:[--thread-content-margin:--spacing(6)] @[72rem]:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"&gt;&lt;div class="[--thread-content-max-width:32rem] @[34rem]:[--thread-content-max-width:40rem] @[64rem]:[--thread-content-max-width:48rem] mx-auto flex max-w-(--thread-content-max-width) flex-1 text-base gap-4 md:gap-5 lg:gap-6 group/turn-messages focus-visible:outline-hidden" tabindex="-1"&gt;&lt;div class="group/conversation-turn relative flex w-full min-w-0 flex-col agent-turn"&gt;&lt;div class="relative flex-col gap-1 md:gap-3"&gt;&lt;div class="flex max-w-full flex-col grow"&gt;&lt;div class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;amp;]:mt-5" dir="auto"&gt;&lt;div class="flex w-full flex-col gap-1 empty:hidden first:pt-[3px]"&gt;&lt;div class="markdown prose dark:prose-invert w-full break-words dark"&gt;
&lt;h4&gt;What Are GTIs and BTIs?&lt;/h4&gt;
&lt;ul&gt;
&lt;!-- TEASER_END --&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GTIs&lt;/strong&gt; define intervals during which the data is considered reliable—free of contamination, instrument artifacts, or observational interruptions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BTIs&lt;/strong&gt; are the complementary regions—gaps between GTIs that typically represent unusable or noisy time segments.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Correct handling of these intervals is critical, especially in &lt;strong&gt;X-ray timing&lt;/strong&gt;, where even small artifacts can skew power spectra, light curves, and periodograms.&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;Worked on Features this week&lt;/h4&gt;
&lt;p&gt;I extended and validated the implementation of GTI filtering in both &lt;code&gt;EventList&lt;/code&gt; and &lt;code&gt;LightCurve&lt;/code&gt; structures:&lt;/p&gt;
&lt;hr&gt;
&lt;h5&gt;&lt;code&gt;apply_gtis(el::EventList, gtis::Matrix)&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;This function filters photon events using a list of GTIs:&lt;/p&gt;&lt;pre class="overflow-visible!"&gt;&lt;div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"&gt;&lt;div class="overflow-y-auto p-4" dir="ltr"&gt;&lt;code class="whitespace-pre! language-julia"&gt;filtered_el = filter_time(t -&amp;gt; gti_start ≤ t ≤ gti_stop, el)
&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;
&lt;p&gt;Only events within the GTI boundaries are retained, and only non-empty segments are returned. This helps preserve valid data while preparing segments for further timing analysis.&lt;/p&gt;
&lt;hr&gt;
&lt;h5&gt;&lt;code&gt;apply_gtis(lc::LightCurve, gtis::Matrix)&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;For light curves, bins are included &lt;strong&gt;only if their centers fall entirely within a GTI&lt;/strong&gt;:&lt;/p&gt;&lt;pre class="overflow-visible!"&gt;&lt;div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"&gt;&lt;div class="overflow-y-auto p-4" dir="ltr"&gt;&lt;code class="whitespace-pre! language-julia"&gt;bin_mask = (lc.time .≥ gti_start) .&amp;amp; (lc.time .≤ gti_stop)
&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;
&lt;p&gt;This strict criterion ensures that bin integrity is preserved—especially important for Fourier-based methods like power spectral density and periodogram calculations. Each resulting segment includes full metadata and is well-formed for downstream analysis.&lt;/p&gt;
&lt;hr&gt;
&lt;h5&gt;&lt;code&gt;fill_bad_time_intervals!(el::EventList, gtis::Matrix)&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;I also implemented an &lt;strong&gt;experimental utility&lt;/strong&gt; for BTI filling. Short gaps (BTIs shorter than a configurable threshold) can be optionally filled with &lt;strong&gt;synthetic events&lt;/strong&gt; to maintain temporal continuity for methods sensitive to uneven sampling.&lt;/p&gt;
&lt;p&gt;Highlights:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BTIs are computed from GTIs and event time range.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Short gaps can be filled with randomly spaced synthetic events.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Synthetic events sample from the original energy distribution (if present).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Metadata is updated to clearly tag synthetic data.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This feature is useful for methods like &lt;strong&gt;Bartlett periodograms&lt;/strong&gt; or other analyses where continuity is required but small gaps might otherwise bias the results&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Stay tuned for the next dive into timing analysis tools in &lt;code&gt;Stingray.jl&lt;/code&gt;. Until then—make your time intervals &lt;em&gt;good&lt;/em&gt; :)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="isolate z-10 w-full basis-auto has-data-has-thread-error:pt-2 has-data-has-thread-error:[box-shadow:var(--sharp-edge-bottom-shadow)] md:border-transparent md:pt-0 dark:border-white/20 md:dark:border-transparent flex flex-col" id="thread-bottom-container"&gt;&lt;div class="text-token-text-secondary relative mt-auto flex min-h-8 w-full items-center justify-center p-2 text-center text-xs md:px-[60px]"&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>JuliaAstro</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250629_0626_kashish2210/</guid><pubDate>Sun, 29 Jun 2025 05:26:00 GMT</pubDate></item><item><title>Moving to the Frontend</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250620_0505_mohyware/</link><dc:creator>mohyware</dc:creator><description>&lt;p&gt;As part of the ongoing development, we’ve now begun focusing on the frontend side of the project, improving the user experience and preparing for more database integrations.&lt;/p&gt;
&lt;h4&gt;Initial Cleanup&lt;/h4&gt;&lt;p&gt;To ensure a clean development workflow, I started by:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Fixing linting and type-checking issues to maintain code quality.&lt;/li&gt;&lt;li&gt;Repairing frontend tests to make sure new changes are verifiable.&lt;/li&gt;&lt;li&gt;This was important to establish a solid pipeline, so any new code added to the frontend can be tested and reviewed confidently.&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Full Dark Mode Support&lt;/h4&gt;&lt;p&gt;A major enhancement was implementing &lt;strong&gt;dark mode&lt;/strong&gt; across the entire frontend, not just the MUI (Material UI) components, but also the &lt;strong&gt;plotting graph area&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;This took some effort as it required:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Migrating from &lt;strong&gt;Joy UI components&lt;/strong&gt; (buttons, inputs, etc.) to &lt;strong&gt;Material UI components&lt;/strong&gt; to ensure compatibility with CssVarsProvider.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Refactoring existing styles&lt;/strong&gt; to align with the new Material UI design system.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The result is a visually cohesive and fully functional dark mode experience!&lt;/p&gt;
&lt;h4&gt;Database Integrations on the Frontend&lt;/h4&gt;&lt;p&gt;I’ve also added frontend support for &lt;strong&gt;ExoMol&lt;/strong&gt; and &lt;strong&gt;NIST&lt;/strong&gt; databases:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ExoMol&lt;/strong&gt; is now functional. However, it still requires optimization. Specifically, setting the broadf variable to False can help reduce unnecessary broadening downloads overhead.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;NIST&lt;/strong&gt; and &lt;strong&gt;HITEMP&lt;/strong&gt; are not yet fully working, as they require login through the HITRAN website. To address this, I’ve added a script that automatically sets the email and password in the RADIS configuration, enabling these databases to work when the application is run.&lt;/li&gt;&lt;/ul&gt;&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=5ae8056490f5" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250620_0505_mohyware/</guid><pubDate>Fri, 20 Jun 2025 04:05:37 GMT</pubDate></item><item><title>🌟 Things Are Getting Interesting!!</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250613_0732_kashish2210/</link><dc:creator>kashish shrivastav</dc:creator><description>&lt;p&gt;Hey everyone!&lt;/p&gt;
&lt;p&gt;If you’ve read my &lt;a href="https://kashish2210.blogspot.com/2025/05/begining-of-gsoc2025.html" rel="noopener"&gt;first blog&lt;/a&gt;, you already know how this journey started — with nervous excitement, inspiring mentors, and my deep love for astronomy. Since then, &lt;strong&gt;things have only gotten more interesting&lt;/strong&gt; — and yes, more challenging, but in the best way possible!&lt;/p&gt;
&lt;h3&gt;Developing, Debugging, and Growing&lt;/h3&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;These past few weeks have felt like a whirlwind of beauty. I’ve found myself diving deeper into spectral analysis, implementing windowing techniques, exploring real research articles, and most excitingly, contributing to the actual development of functions inside Stingray.jl!&lt;/p&gt;
&lt;h3&gt;A New Adventure: EventList and GTI Handling&lt;/h3&gt;
&lt;p&gt;Now comes the exciting part — I’ve been working on &lt;strong&gt;mission support&lt;/strong&gt;, &lt;a href="https://github.com/StingraySoftware/Stingray.jl/pull/49" rel="noopener" target="_new"&gt;PR #49&lt;/a&gt;, where I got to play around with &lt;code&gt;EventList&lt;/code&gt; structures.&lt;/p&gt;
&lt;p&gt;I made a minimal version  &lt;code&gt;EventList&lt;/code&gt; that could read test files, handle metadata smartly, and even filter events using GTIs (Good Time Intervals). My mentor @fergus and I created a  &lt;code&gt;filter_time! &lt;/code&gt;function that makes it super easy to slice time windows and work with just the needed data.&lt;/p&gt;
&lt;p&gt;It felt awesome to write something like this:&lt;/p&gt;
&lt;pre class="overflow-visible!"&gt;&lt;div class="contain-inline-size rounded-2xl border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary"&gt;&lt;div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none rounded-t-2xl"&gt;julia&lt;/div&gt;&lt;div class="overflow-y-auto p-4" dir="ltr"&gt;&lt;code class="whitespace-pre! language-julia"&gt;filter_energy!(&amp;lt;(10u"keV"), filter_time!(&amp;gt;(min_time * u"s"), event_list))
&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;
&lt;p&gt;Elegant, right?&lt;/p&gt;
&lt;p&gt;Also, a quick lesson: &lt;strong&gt;GTIs&lt;/strong&gt; are just two columns — &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;STOP&lt;/code&gt; — telling us when the telescope was actually collecting good data. Handling them properly means our analysis gets cleaner, smarter, and more accurate. I plan to extend my implementation soon to include full GTI support in &lt;code&gt;EventList&lt;/code&gt; directly. Small step, big improvement!&lt;/p&gt;
&lt;h3&gt;Tests, Tests, and More Tests&lt;/h3&gt;
&lt;p&gt;One cool thing I picked up from looking at simpler implementations was &lt;strong&gt;writing smaller, more flexible test cases&lt;/strong&gt;. I’ve started structuring my tests to be interactive and IDE-friendly — so I can quickly check and fix stuff without wrapping everything in big test blocks. It makes debugging &lt;em&gt;way&lt;/em&gt; less stressful. suggested by @fergus&lt;/p&gt;
&lt;h3&gt;What's Next?&lt;/h3&gt;
&lt;p&gt;Right now, I’m:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tweaking the &lt;code&gt;recipbase&lt;/code&gt; functions to make them more modular.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exploring how to use metadata more flexibly in different missions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Working on improving event filtering and data handling inside &lt;code&gt;EventList&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thinking about ways to contribute test utilities that let us simulate dummy FITS files and test logic &lt;em&gt;without&lt;/em&gt; needing real data every time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;✨ Final Thoughts&lt;/h3&gt;
&lt;p&gt;Honestly, it still feels surreal to be working with real tools and contributing code that could one day help researchers uncover deeper insights about the universe. Every commit I make, every tiny improvement I push, and even the bugs I chase down — they’re all helping me grow. Not just as a coder, but as a thinker, a problem solver, and someone who genuinely enjoys the process of learning.&lt;/p&gt;&lt;p&gt;
&lt;/p&gt;&lt;p&gt;What started as an exciting journey has now become something even more thrilling — it feels like I’m leveling up with each challenge I face (yes, just like in my favorite anime, &lt;em&gt;Solo Leveling&lt;/em&gt; 😄). And the best part? This is only the beginning.&lt;/p&gt;</description><category>JuliaAstro</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250613_0732_kashish2210/</guid><pubDate>Fri, 13 Jun 2025 06:32:00 GMT</pubDate></item><item><title>Yeah! I have a GSoC project with Radis</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250607_0949_prtm2110/</link><dc:creator>Pratham</dc:creator><description>&lt;p&gt;Finally, I have been contributing to scientific open source for about a year now and it has taught me a lot I mean a lot, I still remember searching for a simple documentation issue so I could get it merged and call myself a “contributor” haha, and that got me started in scientific open source. Since then, I have been able to make some truly meaningful contributions to many projects, and here I am writing a blog for GSoC with Radis which is a pythonic library for fast line-by-line code for high resolution infrared molecular spectra, under the OpenAstronomy umbrella.&lt;/p&gt;
&lt;p&gt;So my project is cool ngl, and it is titled “Fast Parsing of Large Databases and Execution Bottlenecks” basically there exists a large highly compressed CO₂ spectroscopic database of size 6 GB file that decompresses to about 50 GB and takes at least 2.5 hours to parse and convert into a DataFrame. As you might expect, my project is about significantly reducing the parsing time and finding a workaround for storing only the “necessary” parts of the decompressed file.&lt;/p&gt;
&lt;p&gt;Radis is pythonic and sometimes python gets real slow if not used the way it is meant to be used, so my initial thought was to first clean up the existing code and use vectorised operations and with numba we should be able to see some real optimisation. But then I realized the current implementation already has the right vectorized operations on DataFrames, and Pandas’ vectorized methods are already implemented in optimized C/Cython loops. So there isn’t much more to do here other than replace a few overheads with other operations. After that, as discussed with my mentors I can use a C++ Single Instruction Multiple Data (SIMD) mechanism to parse the file and create a python interface on top of that with pybind11 or cython and other option but this will cost us portability as compilation will be a thing that is to considered. Other approach which is using vulkan API in python as it supports CPU as well GPU parallelism and its cross platform as it will works on all CPU architectures.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;The first thing I did was profile the hit2df function for the NO₂ molecule, which is much smaller compared to CO₂ but uses the same operations. That gave a good idea of the actual bottlenecks and where I need to work.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9OApPZeVUuVw2vAwSCqGQg.png"&gt;&lt;figcaption&gt;Profiling of `hit2df` function for NO₂ molecule&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;As you can see, most of the time is spent in post_process_hitran_data and which is expected because this function calls parse_local_quanta and parse_global_quanta both applies regex across multiple string columns, which is slow at scale, so I switced to fixed‐width slicing to avoid that per-row overhead, of course this was possible as the dataset is consistent and doesn’t require regex at all (I really hope).&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/0*4T1gkGX-4N4_CzO3"&gt;&lt;/figure&gt;&lt;p&gt;This resulted in a clean improvement of about 38%, which will serve as the default option, along with the Vulkan-API mechanism, which I expect will yield a huge optimization compared to the default. That’s something we will see that in the next episode, stay tuned ;)&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=113900105c46" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250607_0949_prtm2110/</guid><pubDate>Sat, 07 Jun 2025 08:49:18 GMT</pubDate></item><item><title>Starting My GSoC Journey with RADIS</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250607_0422_darshvn/</link><dc:creator>Darshan Patil</dc:creator><description>&lt;h4&gt;Getting Started&lt;/h4&gt;&lt;p&gt;A month has passed since the GSoC results came out, and honestly, and the excitement still hasn’t quite settled. That announcement day was pretty intense, my mind was racing, second-guessing everything. But wow, things worked out even better than I’d hoped.&lt;/p&gt;
&lt;p&gt;The community bonding period hit right during my final exams, which was tricky timing. So I focused on what mattered most, getting to know my mentors, joining the weekly calls, and really wrapping my head around the project from a theoretical standpoint.&lt;/p&gt;
&lt;h4&gt;What I’m Working On&lt;/h4&gt;&lt;p&gt;I’m working on something called “&lt;strong&gt;Electronic Spectra for RADIS.&lt;/strong&gt;” Basically, RADIS is this awesome library for modeling rovibrational spectra, but it’s missing one key piece; electronic transitions. That’s where I come in! I want to add that missing functionality and make RADIS even more powerful.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Even though I already knew RADIS pretty well, I spent time going through everything again to make sure I really understood what needed to be done. No point in reinventing the wheel, right? My mentor Nicolas helped me put together a solid plan that actually makes sense.&lt;/p&gt;
&lt;h4&gt;Breaking It Down&lt;/h4&gt;&lt;p&gt;Here’s how I’m breaking it down into four main chunks:&lt;/p&gt;
&lt;p&gt;First up is &lt;strong&gt;OH Electronic Spectra Calculation&lt;/strong&gt; — I’m starting with OH molecules as my test case and building the ability to manually tweak electronic band intensities when things are not in equilibrium as suggested by Nicolas in the project idea, “&lt;em&gt;starting with non-equilibrium spectra of atomic species makes sense since the physics is slightly easier than for molecules&lt;/em&gt;.”&lt;/p&gt;
&lt;p&gt;Then comes &lt;strong&gt;Electronic Temperature Support&lt;/strong&gt; — this is where I’ll add calculations for electronic state populations, assuming the electronic temperature is different from the other temperatures.&lt;/p&gt;
&lt;p&gt;Third is &lt;strong&gt;Equilibrium OH Spectrum&lt;/strong&gt; — putting together everything from the earlier steps to calculate OH spectra when things are in equilibrium.&lt;/p&gt;
&lt;p&gt;Finally, &lt;strong&gt;Extension to ExoMol Molecules&lt;/strong&gt; — taking what I’ve built and making it work for all ExoMol molecules.&lt;/p&gt;
&lt;p&gt;This approach builds on what RADIS already does well while systematically adding the electronic transition stuff, all within the GSoC timeline.&lt;/p&gt;
&lt;h4&gt;The Technical Stuff&lt;/h4&gt;&lt;h4&gt;Working with Data Files&lt;/h4&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pTN3jp3K2szObHXmSYp3gw.png"&gt;&lt;figcaption&gt;Sample of the OH .states file format showing electronic state information and quantum numbers.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;To kick off the first milestone, I’m using the .states file from ExoMol for OH molecules, which has all the electronic state info and quantum numbers. RADIS already has a read_states() function in exomolapi.py that can parse this format, but right now it only extracts:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;i: State counting number&lt;/li&gt;&lt;li&gt;E: State energy&lt;/li&gt;&lt;li&gt;g: State degeneracy&lt;/li&gt;&lt;li&gt;J: Total angular momentum&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I’ll modify this to additionally extract the electronic-specific parameters:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;State: Electronic state label (e.g., X(²Π))&lt;/li&gt;&lt;li&gt;Λ: Electronic angular momentum quantum number&lt;/li&gt;&lt;li&gt;Σ: Spin angular momentum quantum number&lt;/li&gt;&lt;li&gt;Ω: Total electronic angular momentum quantum number&lt;/li&gt;&lt;li&gt;Type: State type (e.g., Ma for main)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This will be the foundation for getting electronic transitions working in RADIS.&lt;/p&gt;
&lt;h4&gt;Making the Calculations Work&lt;/h4&gt;&lt;p&gt;For the population calculations, I’ll be working with the existing partfunc.py file. I'm planning to create a new ElectronicPartitionFunction class and implement the Boltzmann distribution for electronic states. Nicolas referenced a formula from his &lt;a href="https://theses.fr/2020UPAST052"&gt;thesis (Chapter 1, Section 1.1)&lt;/a&gt; that’s relevant to what I’m implementing.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="Boltzmann distribution" src="https://cdn-images-1.medium.com/max/1024/1*bEtk5kQGqpD5kbzwgmLeCQ.png"&gt;&lt;figcaption&gt;Boltzmann distribution&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;All of this will eventually get integrated into SpectrumFactory to compute electronic spectra in SpectrumFactory.non_eq_spectrum(). I'll be adding an electronic temperature (Telec) parameter and thinking about using the overpopulation parameter for manually adjusting electronic band intensities.&lt;/p&gt;
&lt;h4&gt;What’s Next&lt;/h4&gt;&lt;p&gt;I’m planning to work on all this over the next few weeks to nail the first milestone. I’m genuinely excited to be part of this project and can’t wait to learn tons and build something really cool. This is going to be an amazing journey!&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=14b98a245c55" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250607_0422_darshvn/</guid><pubDate>Sat, 07 Jun 2025 03:22:57 GMT</pubDate></item><item><title>GSoC 2025 Blog — Week 1: Starting the Project</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250605_0225_mohyware/</link><dc:creator>mohyware</dc:creator><description>&lt;h4&gt;GSoC 2025 Blog — Starting the Project&lt;/h4&gt;&lt;h4&gt;Kicking Things Off&lt;/h4&gt;&lt;p&gt;The first weeks of GSoC were all about getting familiar with the project, understanding its current state, and laying the groundwork for upcoming work. We began by &lt;strong&gt;listing the key features&lt;/strong&gt; we plan to implement and prioritizing them based on impact and feasibility.&lt;/p&gt;
&lt;h4&gt;Cleaning Up the Repo&lt;/h4&gt;&lt;p&gt;Before diving into development, we focused on improving the current state of the codebase:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Filtered through existing PRs.&lt;/li&gt;&lt;li&gt;Merged those that were ready.&lt;/li&gt;&lt;li&gt;Closed duplicates or low-quality submissions.&lt;/li&gt;&lt;li&gt;Requested changes when necessary.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This cleanup helped fix some bugs and made the repository more maintainable moving forward.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;h4&gt;CI Enhancements&lt;/h4&gt;&lt;p&gt;To ensure future contributions are smoother, we improved the Continuous Integration setup:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Added conditional CI jobs to run &lt;strong&gt;frontend or backend tests&lt;/strong&gt; only when their respective files are changed.&lt;/li&gt;&lt;li&gt;Introduced &lt;strong&gt;Codecov comments&lt;/strong&gt; to show coverage of newly added lines, making it easier to track test quality in PRs.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These changes should streamline reviews and reduce unnecessary CI runs.&lt;/p&gt;
&lt;h4&gt;Early Contributions&lt;/h4&gt;&lt;p&gt;I also started contributing new features and improvements:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Integrated ExoMol and NIST databases&lt;/strong&gt; into the backend.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;While integrating the NIST database, I encountered a tricky error related to the RADIS package:&lt;/p&gt;
&lt;pre&gt;No databank named nist in `/home/mohy/radis.json`. Available databanks: […]&lt;/pre&gt;&lt;p&gt;It turned out that the version of RADIS in the was outdated and didn’t recognize the `nist` databank. This was fixed by upgrading RADIS:&lt;/p&gt;
&lt;pre&gt;pip install — upgrade radis&lt;/pre&gt;&lt;p&gt;Then, another error popped up related to pandas:&lt;/p&gt;
&lt;pre&gt;No such keys(s): 'future.no_silent_downcasting'&lt;/pre&gt;&lt;p&gt;This was caused by version incompatibility, which was resolved by upgrading pandas:&lt;/p&gt;
&lt;pre&gt;pip install — upgrade pandas&lt;/pre&gt;&lt;p&gt;After these upgrades, the databases worked correctly on the backend. The frontend integration and performance optimizations (e.g., caching) are next on my list.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Increased backend test coverage&lt;/strong&gt;, especially for newly added endpoints and database integrations.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;That’s a wrap for the first weeks! It’s been a productive start, and I’m excited to keep building and learning in the coming weeks. Stay tuned for more updates!&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=59a02a05ae58" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250605_0225_mohyware/</guid><pubDate>Thu, 05 Jun 2025 01:25:44 GMT</pubDate></item><item><title>Oops, I’m a GSoC Dev Now?</title><link>http://openastronomy.org/Universe_OA/posts/2025/06/20250604_1803_adnan-itis/</link><dc:creator>Mohammad Adnan</dc:creator><description>&lt;p&gt;Wow! I still can't believe I'm actually in Google Summer of Code! This was a dream, and now here I am, officially past the Community Bonding Period and diving headfirst into the Coding Phase.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;What’s Happening Right Now?&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Right now, I’m sketching out the basic structure of the application interface. The first big task? Fetching event files from specific sources. Sounds simple, right? Well… not quite&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Turns out, HEASARC (the database I need) is having a little meltdown (don’t we all sometimes?). So while I wait for it to get its act together, I’ve been tweaking the pipeline that’ll handle the data retrieval.&lt;/p&gt;
&lt;p&gt;Oh, and my mentor dropped a fun suggestion: "Hey, why not try running this on SciServer?" So guess what I’ll be wrestling with next? &lt;/p&gt;
&lt;p&gt;The last two weeks were chaos. My end-semester exams decided to crash the party right in the middle of the Community Bonding Period. Juggling study sessions, meeting my mentors, and trying not to panic about code I hadn’t even written yet? Yeah, that was… an experience.&lt;/p&gt;
&lt;p&gt;But I survived! And soon, I’ll spill all the tea in a proper "How I Got Into GSoC" post—complete with:&lt;/p&gt;
&lt;p&gt;Why I chose Stingray &lt;b&gt;(spoiler: space data is cool)&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;The emotional rollercoaster of the application process&lt;/p&gt;
&lt;p&gt;Why I may or may not have happy-cried when I got accepted&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;What’s Next? Big Dreams &amp;amp; Messy Code&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;I’ve got so many ideas for this project, and the best part? We’re still figuring things out as we go. It’s like exploring uncharted territory—sometimes you hit a wall, sometimes you find a hidden shortcut, but it’s always an adventure.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;This is my very first GSoC blog, and honestly? I’m just excited to share the journey—bugs, breakthroughs, and all. Thanks for reading! More updates coming soon. 🚀 :})&lt;/p&gt;</description><category>stingray</category><guid>http://openastronomy.org/Universe_OA/posts/2025/06/20250604_1803_adnan-itis/</guid><pubDate>Wed, 04 Jun 2025 17:03:00 GMT</pubDate></item><item><title>Beginning of GSoC 2025</title><link>http://openastronomy.org/Universe_OA/posts/2025/05/20250526_1844_kashish2210/</link><dc:creator>kashish shrivastav</dc:creator><description>&lt;h4&gt;&lt;strong&gt;Hello everyone, and welcome to my first blog!&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;I’m very excited to begin this journey. Since childhood, I’ve been deeply fascinated by &lt;strong&gt;astronomy&lt;/strong&gt;, and today, I finally get to express that passion through writing and sharing my learning experiences with such a great community.&lt;/p&gt;&lt;h5&gt;&lt;strong&gt;A Memorable Start – Meeting My Mentors&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;This week started off on a truly inspiring note. On &lt;strong&gt;May 23rd&lt;/strong&gt;, I had the opportunity to meet my mentors—individuals with deep expertise and experience in the field. At first, I was a bit nervous and hesitant. But the moment the session began, all my fear started fading away.&lt;/p&gt;&lt;p&gt;We began with short introductions and then quickly moved on to discussing plans for the upcoming work. I had a few doubts—some of which I felt were too basic or weird to ask—but I’m so glad I did! My mentors answered them with such clarity and patience. They even gave me valuable suggestions for improving one of my current functions (called &lt;code&gt;recpiec&lt;/code&gt;) and helped us finalize a workflow to proceed with.&lt;/p&gt;&lt;h5&gt;&lt;strong&gt;Learning Through Articles and Real Research&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;Later in the week, I spent time diving deep into articles to strengthen my understanding. One article that particularly stood out was authored by one of my mentors:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;a href="https://iopscience.iop.org/article/10.3847/2041-8213/aaa83b" rel="nofollow" target="_blank"&gt;“No Time for Dead Time: Use the Fourier Amplitude Differences to Normalize Dead-time-affected Periodograms”&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;This article taught me about the problem of &lt;strong&gt;dead time&lt;/strong&gt; in time-series data, especially when analyzing periodic signals using &lt;strong&gt;periodograms&lt;/strong&gt;. Dead time refers to gaps or inactive intervals in data collection, which can significantly distort frequency analysis. The article introduced a technique using &lt;strong&gt;Fourier Amplitude Differences&lt;/strong&gt; to correctly normalize these periodograms, ensuring the results remain accurate and meaningful. This method was new to me and absolutely fascinating!&lt;/p&gt;&lt;h5&gt;&lt;strong&gt;&lt;a href="https://www.slideshare.net/diwakerpant/bartletts-method-pp-ts-11511919" rel="nofollow" target="_blank"&gt;Exploring Bartlett’s Method and Hanning Windows&lt;/a&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;Along with that, I also explored &lt;strong&gt;Bartlett's method&lt;/strong&gt;—a signal processing technique used to reduce the variance of power spectral density estimates. It involves dividing the signal into non-overlapping segments, computing a periodogram for each, and averaging them. This approach provides a smoother, more reliable estimate of the spectrum, which is especially useful in noisy datasets (which are quite common in astronomy!).&lt;/p&gt;&lt;p&gt;Inspired by this, I also implemented the &lt;strong&gt;Hann window&lt;/strong&gt; in my code to taper the signal before applying spectral analysis. This windowing technique helps minimize spectral leakage by reducing the discontinuities at the edges of the signal. I was surprised to see how much of a difference it made in the clarity of results!&lt;/p&gt;&lt;p&gt;


&lt;!-- TEASER_END --&gt;









&lt;/p&gt;&lt;p&gt;Here’s a quick snippet showing how I used the Hann window:&lt;/p&gt;&lt;table class="diff-table tab-size js-diff-table"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="blob-code blob-code-addition"&gt;&lt;span class="blob-code-inner blob-code-marker-addition"&gt;&lt;span class="pl-k" style="color: #ff7b72;"&gt;function&lt;/span&gt; &lt;span class="pl-en" style="color: #d2a8ff;"&gt;hanning&lt;/span&gt;(N&lt;span class="pl-k" style="color: #ff7b72;"&gt;::&lt;/span&gt;&lt;span class="pl-c1" style="color: #79c0ff;"&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr style="background-color: transparent;"&gt;&lt;td class="blob-num blob-num-addition empty-cell"&gt;&lt;/td&gt;&lt;td class="blob-num blob-num-addition"&gt;&lt;/td&gt;&lt;td class="blob-code blob-code-addition"&gt;&lt;span class="blob-code-inner blob-code-marker-addition"&gt;&lt;span class="pl-k" style="color: #ff7b72;"&gt;return&lt;/span&gt; [&lt;span class="pl-c1" style="color: #79c0ff;"&gt;0.5&lt;/span&gt; &lt;span class="pl-k" style="color: #ff7b72;"&gt;*&lt;/span&gt; (&lt;span class="pl-c1" style="color: #79c0ff;"&gt;1&lt;/span&gt; &lt;span class="pl-k" style="color: #ff7b72;"&gt;-&lt;/span&gt; &lt;span class="pl-c1" style="color: #79c0ff;"&gt;cos&lt;/span&gt;(&lt;span class="pl-c1" style="color: #79c0ff;"&gt;2&lt;/span&gt;π &lt;span class="pl-k" style="color: #ff7b72;"&gt;*&lt;/span&gt; n &lt;span class="pl-k" style="color: #ff7b72;"&gt;/&lt;/span&gt; (N&lt;span class="pl-k" style="color: #ff7b72;"&gt;-&lt;/span&gt;&lt;span class="pl-c1" style="color: #79c0ff;"&gt;1&lt;/span&gt;))) &lt;span class="pl-k" style="color: #ff7b72;"&gt;for&lt;/span&gt; n &lt;span class="pl-k" style="color: #ff7b72;"&gt;in&lt;/span&gt; &lt;span class="pl-c1" style="color: #79c0ff;"&gt;0&lt;/span&gt;&lt;span class="pl-k" style="color: #ff7b72;"&gt;:&lt;/span&gt;N&lt;span class="pl-k" style="color: #ff7b72;"&gt;-&lt;/span&gt;&lt;span class="pl-c1" style="color: #79c0ff;"&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="blob-num blob-num-addition empty-cell"&gt;&lt;/td&gt;&lt;td class="blob-num blob-num-addition"&gt;&lt;br&gt;&lt;/td&gt;&lt;td class="blob-code blob-code-addition"&gt;&lt;span class="blob-code-inner blob-code-marker-addition"&gt;&lt;span class="pl-k" style="color: #ff7b72;"&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: left;"&gt;I have pasted the plots also to get more insights :)&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://blogger.googleusercontent.com/img/a/AVvXsEiv8rx6YEf03zFZgH-4NN0vtJSzohH_w6l8HwrNaTyCjmWGieJGwKVAlIixqN9GfYbOnJYApuFSskS7ccfUySGzgoJUA27FdE3nluw5pxc2aZSgdKI-8IspMORgeUwOz8gOJIVI-rv4y50Xu-CSeWj6A3mIZooPcO5FLic0Wq5P4L5kS7fDyDzDypG-Bo4v" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img alt="" height="347" src="https://blogger.googleusercontent.com/img/a/AVvXsEiv8rx6YEf03zFZgH-4NN0vtJSzohH_w6l8HwrNaTyCjmWGieJGwKVAlIixqN9GfYbOnJYApuFSskS7ccfUySGzgoJUA27FdE3nluw5pxc2aZSgdKI-8IspMORgeUwOz8gOJIVI-rv4y50Xu-CSeWj6A3mIZooPcO5FLic0Wq5P4L5kS7fDyDzDypG-Bo4v=w405-h347" width="405"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;Oh! u have read my entire blog, thank u :)&lt;/div&gt;&lt;/div&gt;</description><category>JuliaAstro</category><guid>http://openastronomy.org/Universe_OA/posts/2025/05/20250526_1844_kashish2210/</guid><pubDate>Mon, 26 May 2025 17:44:00 GMT</pubDate></item><item><title>Final GSoC Report</title><link>http://openastronomy.org/Universe_OA/posts/2024/10/20241006_2230_deadspheroid/</link><dc:creator>DeadSpheroid</dc:creator><description>&lt;p class="intro"&gt;In this post, I'll be discussing my GSoC'24 project, the goals set, work done, and future scope&lt;/p&gt;

&lt;h2 id="about-openastronomy"&gt;About OpenAstronomy&lt;/h2&gt;
&lt;!-- TEASER_END --&gt;
&lt;p align="center" width="100%"&gt;
&lt;img alt="OpenAstronomy Logo" src="https://deadspheroid.github.io/my-blog/assets/img/logoOA_svg.png" style="margin-bottom: 0; margin-top: 24px;"&gt;
&lt;/p&gt;
&lt;p&gt;OpenAstronomy is a collaboration between open source astronomy and astrophysics projects to share resources, ideas, and to improve code.&lt;/p&gt;

&lt;p&gt;OpenAstronomy consists of many different projects: astropy, sunpy, stingray, radis&lt;/p&gt;

&lt;p&gt;and of course GNU Astronomy Utilities (Gnuastro)&lt;/p&gt;

&lt;h2 id="about-gnuastro"&gt;About Gnuastro&lt;/h2&gt;
&lt;p align="center" width="100%"&gt;
&lt;img alt="Gnuastro Logo" src="https://deadspheroid.github.io/my-blog/assets/img/gnu-logo.png" style="margin-bottom: 0; margin-top: 24px;"&gt;
&lt;/p&gt;

&lt;p&gt;Gnuastro is an official GNU package that consists of many CLI programs as well as library functions for manipulation and analysis of astronomical data.
Something important to note about Gnuastro is that it is written entirely in C99 and shell script.
The Gnuastro team meets every Tuesday to exchange notes and review progress&lt;/p&gt;

&lt;h2 id="goals-of-the-project"&gt;Goals of the project&lt;/h2&gt;

&lt;p&gt;Going into this project, there were two main goals decided&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Setting up the low level wrapper infrastructure for using OpenCL within Gnuastro, putting minimal requirements on the developers/users to know OpenCL.&lt;/li&gt;
&lt;li&gt;Parallelizing Gnuastro subroutines using the aforementioned wrappers to offload compute-heavy tasks to the GPU.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first goal deals with how users of the library would interact with the OpenCL modules. Ideally, you would want the users to have no knowledge about OpenCL and only interact with it through GNUAstro.&lt;/p&gt;

&lt;p&gt;The second goal deals with analyzing parts of the Gnuastro library, identifying easy to parallelize sections and writing optimised OpenCL Kernels for them, leveraging the wrapper infrastructure for execution.&lt;/p&gt;

&lt;p&gt;The majority of my work lives &lt;a href="https://github.com/DeadSpheroid/gnuastro/tree/final"&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="pre-gsoc"&gt;Pre GSoC&lt;/h2&gt;

&lt;p&gt;Prior to GSoC, my experience consisted mostly of Deep Learning and Natural Language Processing. My knowledge of GPU Processing was limited and naive.&lt;/p&gt;

&lt;p&gt;During the proposal drafting period, candidates were asked to submit a task, which was implementing simple image convolution on both CPU and GPU using OpenCL.&lt;/p&gt;

&lt;h2 id="during-gsoc"&gt;During GSoC&lt;/h2&gt;

&lt;p&gt;Work on GSoC kicked off around May 1st with the first objective being&lt;/p&gt;

&lt;h3 id="build-system-integration"&gt;Build System Integration&lt;/h3&gt;

&lt;p&gt;Now, Gnuastro being a GNU project uses the GNU Build System, GNU Autotools(Autoconf, Automake, Libtool).&lt;/p&gt;

&lt;p&gt;This was a completely new build system for me to work with and I had to get the library to include OpenCL and link against the OpenCL library at compile time.&lt;/p&gt;

&lt;p&gt;Thanks to some helpful pointers from Mohammad, I was able to grasp the working pretty quickly and was able to set up Gnuastro to include and build with OpenCL if it was detected on the system.&lt;/p&gt;

&lt;p&gt;For more information, you can read &lt;a href="https://deadspheroid.github.io/my-blog/post/GettingStarted/"&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="wrapper-infrastructure"&gt;Wrapper Infrastructure&lt;/h3&gt;

&lt;p&gt;The next goal was to create wrappers around the OpenCL C API, for various operations(data transfer, launching kernels, querying devices).&lt;/p&gt;

&lt;p&gt;This was done in the form of a new Gnuastro module called &lt;code class="language-plaintext highlighter-rouge"&gt;cl-utils.c&lt;/code&gt; which contained&lt;/p&gt;

&lt;h5 id="initialisation"&gt;Initialisation&lt;/h5&gt;
&lt;p&gt;Functions dealing with initialising OpenCL and creating, destroying OpenCL objects&lt;/p&gt;

&lt;h5 id="data-transfer-functions"&gt;Data Transfer Functions&lt;/h5&gt;
&lt;p&gt;Functions dealing with data transfer to and from the GPU.
This is one of the biggest overheads in GPU Programming. Additionally, OpenCL presented another challenge in the form of transferring structs to the GPU, which was problematic as one of Gnuastro’s most important data structures &lt;code class="language-plaintext highlighter-rouge"&gt;gal_data_t&lt;/code&gt; could not be directly transferred.&lt;/p&gt;

&lt;p&gt;So, this module provides two ways of transferring data to the GPU&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OpenCL Buffers
and&lt;/li&gt;
&lt;li&gt;OpenCL SVM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Buffers are intended to be used for simple data structures, while OpenCL SVM is better with more complex data structures involving internal pointers.&lt;/p&gt;

&lt;p&gt;The interface looks something like this&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C"&gt;void
gal_cl_write_to_device (cl_mem *buffer, void *mapped_ptr,
cl_command_queue command_queue);

void *
gal_cl_read_to_host (cl_mem buffer, size_t size,
cl_command_queue command_queue);
.
.
.
gal_data_t *
gal_cl_alloc_svm (size_t size_of_array, size_t size_of_dsize,
cl_context context, cl_command_queue command_queue);

void
gal_cl_map_svm_to_cpu (cl_context context, cl_command_queue command_queue,
void *svm_ptr, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information on the two, and a comparison see &lt;a href="https://deadspheroid.github.io/my-blog/post/ExploringFurther/"&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h5 id="executing-kernels"&gt;Executing Kernels&lt;/h5&gt;
&lt;p&gt;Now, the main code running on the GPU is the OpenCL Kernel, usually defined in a .cl file and compiled at runtime.&lt;/p&gt;

&lt;p&gt;The idea when making this module, was to keep the interface as similar to the original pthreads &lt;code class="language-plaintext highlighter-rouge"&gt;gal_threads_spin_off()&lt;/code&gt; interface that Gnuastro already had. So i created a &lt;code class="language-plaintext highlighter-rouge"&gt;gal_cl_threads_spinoff()&lt;/code&gt; function, taking information like the kernel filepath, number of inputs, list of inputs, number of threads executed and more.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-C"&gt;typedef struct clprm
{
char               *kernel_path; /* Path to kernel.cl file */
char               *kernel_name; /* Name of __kernel function */
char             *compiler_opts; /* Additional compiler options */
cl_device_id          device_id; /* Device to be targeted */
cl_context              context; /* Context of OpenCL in use */
int             num_kernel_args; /* Number of total kernel arguments */
int                num_svm_args; /* Number of SVM args*/
void              **kernel_args; /* Array of pointers to kernel args */
size_t       *kernel_args_sizes; /* Sizes of non SVM args */
int          num_extra_svm_args; /* Number of implicit SVM args */
void           **extra_svm_args; /* Array of pointers to these args */
int                    work_dim; /* Work dimension of job - 1,2,3 */
size_t        *global_work_size; /* Array of global sizes of size work_dim */
size_t         *local_work_size; /* Array of local sizes of size work_dim */
} clprm;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These wrappers were not developed all at once, but rather in conjunction with the next section, writing wrappers as and when I needed them.&lt;/p&gt;

&lt;h3 id="parallelized-subroutines"&gt;Parallelized Subroutines&lt;/h3&gt;
&lt;p&gt;To achieve the goal of GPU acceleration, first we needed to identify parts of the library that could be parallelized.
Its important to note that not everything can be parallelized, and just because something can be, doesnt mean it should be.&lt;/p&gt;

&lt;p&gt;The most obvious candidate for this of course was 2D Image Convolution, already implemented in Gnuastro in the &lt;code class="language-plaintext highlighter-rouge"&gt;astconvolve&lt;/code&gt; module.&lt;/p&gt;

&lt;h5 id="same-code-on-cpu-and-gpu"&gt;Same code on CPU and GPU&lt;/h5&gt;
&lt;p&gt;The initial idea was to have the exact same code running on both the CPU(via pthread) and the GPU(via OpenCL). This is possible because OpenCL Kernels are based on OpenCL C which is a variant(kind of a subset) of C99.&lt;/p&gt;

&lt;p&gt;This is because Gnuastro is a “minimal dependencies” package and having two separate implementations would greatly overcomplicate the codebase.&lt;/p&gt;

&lt;p&gt;However for the time being, this idea was shelved, till I had a working implementation of convolution in OpenCL.&lt;/p&gt;

&lt;h5 id="convolution"&gt;Convolution&lt;/h5&gt;
&lt;p&gt;I got to work creating a new module &lt;code class="language-plaintext highlighter-rouge"&gt;cl-convolve.c&lt;/code&gt; containing the new implementation of convolution &lt;code class="language-plaintext highlighter-rouge"&gt;gal_convolve_cl()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The exact code can be viewed &lt;a href="https://github.com/DeadSpheroid/gnuastro/blob/final/lib/cl-convolve.c"&gt;here&lt;/a&gt;, but in short&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Transfer input, kernel and output images to GPU&lt;/li&gt;
&lt;li&gt;Spin off a thread for each pixel in the input, convolving that particular pixel.&lt;/li&gt;
&lt;li&gt;Copy the output image back to CPU&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id="additional-features"&gt;Additional features&lt;/h5&gt;
&lt;p&gt;However, Gnuastro doesn’t use a &lt;strong&gt;simple 2D convolution&lt;/strong&gt;, it also performs an additional three important tasks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Edge Correction:&lt;/strong&gt; Pixels near the edge use a different kernel weight than others. More info &lt;a href="https://www.gnu.org/savannah-checkouts/gnu/gnuastro/manual/html_node/Edges-in-the-spatial-domain.html"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NAN Checking:&lt;/strong&gt; Often, images captured by astronomical cameras, have missing pixels(represented as NANs). These pixels are to be ignored.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channels:&lt;/strong&gt; Cameras use multiple different sensors to capture images, and convolution should not mix pixels from different sensors. For a better idea, read &lt;a href="https://www.gnu.org/savannah-checkouts/gnu/gnuastro/manual/html_node/Tessellation.html"&gt;Gnuastro’s explanation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first two were rather easy to implement, but the third was a bit troublesome, especially because the existing implementation of gnuastro was complex and hard to understand.&lt;/p&gt;

&lt;p&gt;Eventually however, with a little bit of math it was possible, and the final kernel looked like &lt;a href="https://github.com/DeadSpheroid/gnuastro/blob/4442a544db5d33d64290ac0b15a97bd627ad6335/bin/convolve/astconvolve-conv.cl"&gt;this&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;After these parts were completed, now, all that was left was to actually integrate it properly with Gnuastro.&lt;/p&gt;

&lt;h5 id="optimised-convolution"&gt;Optimised Convolution&lt;/h5&gt;
&lt;p&gt;The power of GPUs comes not from the many threads that are launched, but rather from the many optimisations possible, from organising threads into blocks, to special kinds of memory. I decided to try optimising Convolution based on Labeeb’s suggestion of using shared memory.&lt;/p&gt;

&lt;p&gt;However most of the optimisation out there are for CUDA, not OpenCL, but the principles in question were the same. Thanks to &lt;a href="https://www.evl.uic.edu/sjames/cs525/final.html"&gt;this article&lt;/a&gt;, I was able to implement an optimised 2Dconvolution kernel in OpenCL.&lt;/p&gt;

&lt;p&gt;The results of the optimisation were surprisingly positive:
For a 5000 x 5000 image, times recorded for the convolution operation(excluding data reading/writing in seconds were)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt; &lt;/th&gt;
&lt;th style="text-align: center;"&gt;Pthread&lt;/th&gt;
&lt;th style="text-align: center;"&gt;OpenCL-CPU&lt;/th&gt;
&lt;th style="text-align: center;"&gt;OpenCL-GPU&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;w/out optimisations&lt;/td&gt;
&lt;td style="text-align: center;"&gt;1.014374&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0.918015&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;strong&gt;0.025869&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;w/ optimisations&lt;/td&gt;
&lt;td style="text-align: center;"&gt;1.053622&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0.326756&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;strong&gt;0.004184&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Thats a speedup of &lt;strong&gt;~6.2 times&lt;/strong&gt; over the non optimised GPU run, and &lt;strong&gt;~242 times&lt;/strong&gt; over the existing pthread implementation in Gnuastro!&lt;/p&gt;

&lt;p&gt;Further optimisations are possible using special native functions like MUL24 and constant memory. But the details of those and how these optimisation work is a topic for a separate post.&lt;/p&gt;

&lt;h5 id="revisiting-same-code-on-cpu-vs-gpu"&gt;Revisiting Same Code on CPU vs GPU&lt;/h5&gt;
&lt;p&gt;After a discussion, it was decided that the best path forward for OpenCL in Gnuastro would be to completely replace the existing pthread implementation.&lt;/p&gt;

&lt;p&gt;In essence, the existing “convoluted” convolution implementation would be replaced with my new one, allowing the same code to be ran in 3 different ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;With OpenCL on the GPU&lt;/li&gt;
&lt;li&gt;With OpenCL on the CPU&lt;/li&gt;
&lt;li&gt;With GCC+Pthreads on the CPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This decision was made to adhere to the Gnuastro philosophy of “Minimal Dependencies” so the user does not have to install many packages just to use the library.&lt;/p&gt;

&lt;p&gt;It was challenging, owing to the different styles in which we write code for a CPU device versus a GPU device. But I managed to get a partially working version using some C macros here and there to do so. It still fails some Gnuastro tests, which is yet to be resolved.&lt;/p&gt;

&lt;p&gt;However, doing so prevents the library from utilising the full power of GPUs with several GPU specific optimisations seen previously.&lt;/p&gt;

&lt;h5 id="using-the-opencl-modules-in-your-program"&gt;Using the OpenCL modules in your program&lt;/h5&gt;
&lt;p&gt;Finally, when a user wants to use Gnuastro’s OpenCL capabilities within their own programs, the flow followed would look like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intialize OpenCL&lt;/li&gt;
&lt;li&gt;Transfer Input to Device&lt;/li&gt;
&lt;li&gt;Write an OpenCL Kernel&lt;/li&gt;
&lt;li&gt;Spinoff Threads&lt;/li&gt;
&lt;li&gt;Copy Output back to Host&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets take an example where we need to simply add two fits images.&lt;/p&gt;

&lt;h6 id="initialize-opencl"&gt;Initialize OpenCl&lt;/h6&gt;
&lt;pre&gt;&lt;code class="language-C"&gt;  cl_context context;
cl_platform_id platform_id;
cl_device_id device_id;

gal_cl_init (CL_DEVICE_TYPE_GPU, &amp;amp;context, &amp;amp;platform_id, &amp;amp;device_id);
cl_command_queue command_queue
= gal_cl_create_command_queue (context, device_id);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This initializes and OpenCL context, among other objects for use in future function calls.&lt;/p&gt;

&lt;h6 id="transfer-input-to-device"&gt;Transfer Input to Device&lt;/h6&gt;
&lt;p&gt;Make use of &lt;code class="language-plaintext highlighter-rouge"&gt;gal_cl_copy_data_to_gpu()&lt;/code&gt; to transfer the loaded fits files to the GPU, passing the previously initialized context and command queue. Make sure the command queue finishes before proceeding ahead through &lt;code class="language-plaintext highlighter-rouge"&gt;gal_cl_finish_queue()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-C"&gt;  gal_data_t *input_image1_gpu
= gal_cl_copy_data_to_gpu (context, command_queue, input_image1);
gal_data_t *input_image2_gpu
= gal_cl_copy_data_to_gpu (context, command_queue, input_image2);
gal_data_t *output_image_gpu
= gal_cl_copy_data_to_gpu (context, command_queue, output_image);

gal_cl_finish_queue (command_queue);
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id="write-an-opencl-kernel"&gt;Write an OpenCL Kernel&lt;/h6&gt;
&lt;p&gt;First, any custom structs you use, must be defined in the kernel, here we define gal_data_t.&lt;/p&gt;

&lt;p&gt;Then, you create the “per thread” function that will be executed, prefixed by &lt;code class="language-plaintext highlighter-rouge"&gt;__kernel&lt;/code&gt; and always returning &lt;code class="language-plaintext highlighter-rouge"&gt;void&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the arguments, mention the pointers to the inputs/outputs, as well as a &lt;code class="language-plaintext highlighter-rouge"&gt;__global&lt;/code&gt; identifier, since your input is acessible by all threads.&lt;/p&gt;

&lt;p&gt;Make use of OpenCl’s &lt;code class="language-plaintext highlighter-rouge"&gt;get_global_id(0)&lt;/code&gt; to get the thread id along the 0th dimension.&lt;/p&gt;

&lt;p&gt;Perform the core operation of your program.&lt;/p&gt;

&lt;p&gt;Putting it all together, it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-C"&gt;typedef struct  __attribute__((aligned(4))) gal_data_t
{
/* Basic information on array of data. */
void *restrict array; /* Array keeping data elements.               */
uchar type;         /* Type of data (see 'gnuastro/type.h').      */
size_t ndim;          /* Number of dimensions in the array.         */
size_t *dsize;        /* Size of array along each dimension.        */
size_t size;          /* Total number of data-elements.             */
.
.
.
/* Pointers to other data structures. */
struct gal_data_t *next;  /* To use it as a linked list if necessary.   */
struct gal_data_t *block; /* 'gal_data_t' of hosting block, see above.  */
} gal_data_t;

__kernel void
add(__global gal_data_t *input_image1,
__global gal_data_t *input_image2,
__global gal_data_t *output_image)
{
int id = get_global_id(0);

float *input_array1 = (float *)input_image1-&amp;gt;array;
float *input_array2 = (float *)input_image2-&amp;gt;array;
float *output_array = (float *)output_image-&amp;gt;array;

output_array[id] = input_array1[id] + input_array2[id];
return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id="spin-off-threads"&gt;Spin Off Threads&lt;/h6&gt;
&lt;p&gt;Make use of the &lt;code class="language-plaintext highlighter-rouge"&gt;clprm&lt;/code&gt; struct defined in &lt;code class="language-plaintext highlighter-rouge"&gt;gnuastro/cl-utils.h&lt;/code&gt; to group all the relevant parameters.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Kernel Path&lt;/code&gt; is the filepath to the OpenCL Kernel you just wrote.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Kernel Name&lt;/code&gt; is the name of the function you defined with &lt;code class="language-plaintext highlighter-rouge"&gt;__kernel&lt;/code&gt; earlier.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Compiler Options&lt;/code&gt; is a string of any special compiler options like macros/debug options you wish to use for the kernel.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Device Id &amp;amp; Context&lt;/code&gt; are the objects intialized in the first step.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Number of Kernel Arguments&lt;/code&gt; is the number of kernel arguments.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Number of SVM Arguments&lt;/code&gt; is the number of arguments that use SVM(all the gal_data_t’s)&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Kernel Arguments&lt;/code&gt; is an array to void pointers of kernel arguments.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Number of Extra SVM Arguments&lt;/code&gt; is the number of arguments that are implicitly referenced with a struct. For example, &lt;code class="language-plaintext highlighter-rouge"&gt;input_image1_gpu&lt;/code&gt; is directly referenced as a kernel argument, but the &lt;code class="language-plaintext highlighter-rouge"&gt;input_image1_gpu-&amp;gt;array&lt;/code&gt; is implicitly referenced.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Extra SVM Arguments&lt;/code&gt; is an array of void pointers to the aforementioned special arguments.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Work Dim&lt;/code&gt; is the number of dimensions of the threads (1, 2, 3)
For example, an array would have 1 dimension(0,1,2,…34,35,36) x
an image would have 2 dimensions(0:0, 0:1, 1:0, 1:1,….) x:y
a volume would have 3 dimensions.&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Global Work Size&lt;/code&gt; is the total number of threads spun off&lt;/p&gt;

&lt;p&gt;&lt;code class="language-plaintext highlighter-rouge"&gt;Local Work Size&lt;/code&gt; is the number of threads in a block on one GPU core. Leaving it blank lets the device choose this number.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-C"&gt;
clprm *sprm = (clprm *)malloc (sizeof (clprm));

void *kernel_args[] = { (void *)input_image1_gpu, (void *)input_image2_gpu,
(void *)output_image_gpu };

void *svm_ptrs[]
= { (void *)input_image1_gpu-&amp;gt;array, (void *)input_image2_gpu-&amp;gt;array,
(void *)output_image_gpu-&amp;gt;array };

size_t numactions = input_image1-&amp;gt;size;

sprm-&amp;gt;kernel_path = "./lib/kernels/add.cl";
sprm-&amp;gt;kernel_name = "add";
sprm-&amp;gt;compiler_opts = "";
sprm-&amp;gt;device_id = device_id;
sprm-&amp;gt;context = context;
sprm-&amp;gt;num_kernel_args = 3;
sprm-&amp;gt;num_svm_args = 3;
sprm-&amp;gt;kernel_args = kernel_args;
sprm-&amp;gt;num_extra_svm_args = 3;
sprm-&amp;gt;extra_svm_args = svm_ptrs;
sprm-&amp;gt;work_dim = 1;
sprm-&amp;gt;global_work_size = &amp;amp;numactions;
sprm-&amp;gt;local_work_size = NULL;

gal_cl_finish_queue (command_queue);
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id="copy-output-back-to-host"&gt;Copy Output back to Host&lt;/h6&gt;
&lt;pre&gt;&lt;code class="language-C"&gt;gal_cl_read_data_to_cpu(context, command_queue, output_image_gpu);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete program can be accessed &lt;a href="https://github.com/DeadSpheroid/gnuastro/blob/final/cl-example-add-fits.c"&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="post-gsoc"&gt;Post GSoC&lt;/h2&gt;
&lt;p&gt;Now, that the wrapper infrastructure is set up and convolution is implemented, whats left is to test the implementation against real life scenarios to make sure it lives up to the expectations of the Gnuastro users.
We also need to come up with a consistent way to execute the same kernel on both OpenCL and GCC, as mentioned earlier.&lt;/p&gt;

&lt;p&gt;Additionally, now that work on one module is complete, it opens the scope for more modules to be implemented on the GPU (like statistics, interpolation and more)&lt;/p&gt;

&lt;h2 id="acknowledgements"&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;GSoC has been an incredible learning experience for me both from a technical view and from a personal view.&lt;/p&gt;

&lt;p&gt;On the technical side, I learned a lot about one of my favourite domains in Low Level Programming, GPU Programming and my understanding of how to write libraries that are easy to use, performant and above and all else, FOSS, improved tremendously. It’s one thing when you learn and write code for your own personal projects, but it’s a completely different experience contributing to something like Gnuastro.&lt;/p&gt;

&lt;p&gt;On the personal side, the weekly meetings with the Gnuastro team were always extremely engaging and i got to learn a lot from the team, Giacomo’s work on Astrometry, Alvaro’s work on Deconvolution and Ronald too. Their feedback on stuff like debugging using valgrind/gdb and references to other projects using OpenCL, alongside other topics has been invaluable.&lt;/p&gt;

&lt;p&gt;Above and all else im thankful to my mentor &lt;a href="https://akhlaghi.org/"&gt;Mohammad Akhlagi&lt;/a&gt;. Its been amazing getting to interact with someone so experienced and I learned a lot from him, ranging from Astronomy to Hacking the GNU C Library. He was always patient and understanding of my other responsibilities and allowed me to work at my own pace. I’m grateful to him for the opportunity to be a part of the Gnuastro community.&lt;/p&gt;

&lt;p&gt;Finally, I can’t explain how indebited I am to my mentor &lt;a href="https://www.linkedin.com/in/labib-asari/?originalSubdomain=in"&gt;Labeeb Asari&lt;/a&gt;. His knowledge about GPU Programming has been vital to my work on this project and I’m grateful to him for introducing me to the Gnuastro team. From &lt;a href="https://github.com/ProjectX-VJTI"&gt;Project X&lt;/a&gt;, to GSoC to college in general, he has been a big help in everything I’ve done and im glad to have him as a mentor and friend.&lt;/p&gt;

&lt;p&gt;A huge thank you to the Google Summer of Code Team for undertaking this wonderful initiative and I hope they continue this program in future years.&lt;/p&gt;</description><category>gnuastro</category><guid>http://openastronomy.org/Universe_OA/posts/2024/10/20241006_2230_deadspheroid/</guid><pubDate>Sun, 06 Oct 2024 21:30:00 GMT</pubDate></item></channel></rss>