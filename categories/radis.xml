<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts about radis)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/categories/radis.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 27 Jun 2023 01:22:37 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Comparing memory performance of Vaex and Pandas</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230624_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;After completing all the changes to compute Spectrum using Vaex , I compared the memory used during the execution of the program . I used tracemalloc to compute memory uses to compute Spectrum .&lt;/p&gt;

&lt;h4 id="computing-the-spectrum"&gt;Computing the spectrum&lt;/h4&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Following code is used , and memory maximum memory used during the execution of this code is recorded for Vaex and Pandas&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;
from radis import calc_spectrum
import tracemalloc
tracemalloc.start()

s, factory_s = calc_spectrum(1800, 2500,         # cm-1
molecule='H2O',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=700,           # K
mole_fraction=0.1,
path_length=1,      # cm
databank='hitemp',  # or 'hitemp', 'geisa', 'exomol'
wstep='auto',
use_cached=False,
engine='pandas',
return_factory=True,
)

s.apply_slit(0.5, 'nm')       # simulate an experimental slit
s.plot('radiance')

print(tracemalloc.get_traced_memory())
tracemalloc.stop()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id="results"&gt;Results&lt;/h4&gt;

&lt;p&gt;It can be seen from the graph below that Vaex takes very less memory space in comparison to Pandas.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Vaex Comparison" src="https://1someshverma.github.io/images/vaexcomparison.png"&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230624_0000_1someshverma/</guid><pubDate>Fri, 23 Jun 2023 23:00:00 GMT</pubDate></item><item><title>Implementation of the Kurucz database to Radis</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230617_2033_menasrac/</link><dc:creator>Racim MENASRIA</dc:creator><description>&lt;p&gt;As planed in my last article, I started my project by adding a first database to Radis¬†:¬†Kurucz.&lt;/p&gt;
&lt;p&gt;I based my work on a existing class developed in Exojax. I reviewed the associated methods that allowed to download the data from the database, store it in numpy arrays and extract the key information from it for further calculation.&lt;/p&gt;
&lt;p&gt;By running a few examples on Exojax, I got familiar with the structure and nature of the data and key functions.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;However, I noticed a problem in the install command of Radis‚Äôs sister code Exojax while running theses examples. After further investigation with my mentors and the Exojax team, it appeared to be a jax problem so we couldn‚Äôt fix it for the moment.&lt;br&gt;Since I could only make them work on a wsl environment, I couldn‚Äôt afford to import jax libraries used in the AdbKurucz database implemented to Exojax. This is the reason why I had to adapt the structure of the data and methods and stick to Pandas dataframes and numpy¬†arrays.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;First try¬†: using a DatabaseManager structure&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;As a explained it in the previous article, Radis has developed a special Class the handle the database processes. Since Kurucz is an atomic Database, I tried to implement it by making it inherit from the DatabaseManager class and setting the molecule parameter to ‚ÄúNone‚Äù. Unfortunately, it led to many exceptions in the methods that I gave up on this¬†idea.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Second try¬†: using Exojax methods without jax¬†imports&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;This approach provided very nice results because the major part of the methods were already efficient. &lt;br&gt;Nevertheless I had some errors because of the data wasn‚Äôt loaded properly or syntax errors had broken a few parts of the¬†code.&lt;/p&gt;
&lt;p&gt;I finally managed to load, store and use the data from¬†Kurucz.&lt;/p&gt;
&lt;p&gt;Then I added an example to show how this new database can be¬†used.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oJXYNuWaqdZFCpuhYTNSjw.png"&gt;&lt;/figure&gt;&lt;p&gt;This is the first spectrum that I obtained from the Kurucz database for¬†Fe.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;A bit more explanations:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The population of the lower energy level of a given transition is the number of atoms that are in that energy state at any given time. So if you have a large population in a certain energy state, you have a lot of atoms that are able to make the transition and therefore emit a photon. Einstein‚Äôs coefficient A for a particular transition is a measure of the probability of that transition occurring. So if A is large, then each atom has a high chance of making the transition and emitting a photon. Thus, the intensity of the spectral line (i.e. the number of photons emitted per unit time) is proportional to both the population of the lower energy level (the number of atoms capable of making the transition) and to A (the probability that each atom actually makes the transition). So the intensity can be approximately represented as A * population.&lt;/p&gt;
&lt;p&gt;The users can chose the temperature and the function then interpolates the values from the database and plots the spectrum.&lt;/p&gt;
&lt;p&gt;In order to generalize this to all the atoms and ions of the database, I had to adjust the function load_pf_Barklem2016() from Exojax and fix an error in the way the partition functions were extracted.&lt;/p&gt;
&lt;p&gt;Now I can load the data and use it properly. For Kurucz‚Äôs data, each file corresponds to a single species of atom only. For example, ‚Äúgf2600.all‚Äù is dedicated to absorption lines of ‚Äúneutral iron atoms‚Äù. The ‚Äú26‚Äù is the atomic number of iron, followed by a ‚Äú00‚Äù indicating zero ionization (=neutral; Fe I). For example, if you want to use spectral lines of singly-ionized sodium (Na II or Na+), you should download ‚Äúgf1101.all‚Äù.&lt;/p&gt;
&lt;p&gt;Here is another example for¬†Ca.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*q_748Zt_K4rqW5fWtFAdTQ.png"&gt;&lt;/figure&gt;&lt;h4&gt;&lt;strong&gt;What is next¬†?&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;I will end up this week by adding a few tests to ensure my code doesn‚Äôt break any part of the Radis architecture and may go for a PR in the next¬†days.&lt;/p&gt;
&lt;p&gt;Then the next step for Week 4 will be to implement the TheoReTS database to Radis¬†.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=27c2724fde74" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230617_2033_menasrac/</guid><pubDate>Sat, 17 Jun 2023 19:33:30 GMT</pubDate></item><item><title>Refactoring code for calculating Spectrum Using Vaex dataframe</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230616_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;After the community bonding period , I continued refactoring the code for vaex .
I have the following the things in this period&lt;/p&gt;

&lt;!-- TEASER_END --&gt;
&lt;ul&gt;
&lt;li&gt;Test cases for fetch_databank() and load_databank() functions&lt;/li&gt;
&lt;li&gt;Replaced the portion of code which is different for Vaex as compared with Pandas&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="test-cases-for-loading-dataframe-in-vaex-dataframe-format"&gt;Test Cases for loading dataframe in Vaex dataframe format&lt;/h4&gt;

&lt;p&gt;Test Cases are written to test the following :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Number of columns are same in both Vaex dataframe and Pandas dataframe&lt;/li&gt;
&lt;li&gt;Number of lines in same in both the dataframe&lt;/li&gt;
&lt;li&gt;Compared the value of some of the column with corresponding the column value&lt;/li&gt;
&lt;li&gt;Calculated the spectrum of CO molecule under equilibrium and compared both the spectrum are the same&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One of the test case added is following , I have simply fetched dataframe in Vaex dataframe format and pandas , then compared the if the above conditions are satisfied are not .&lt;/p&gt;
&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;def test_df_from_vaex_and_pandas():
from radis.lbl import SpectrumFactory

sf = SpectrumFactory(
2284,
2300,
wstep=0.001,  # cm-1
pressure=20 * 1e-3,  # bar
cutoff=0,
path_length=0.1,
mole_fraction=400e-6,
molecule="CO",
isotope="1,2",
medium="vacuum",
truncation=5,
verbose=0,
)
sf.engine = 'vaex'
sf.warnings["MissingSelfBroadeningWarning"] = "ignore"
# Testing Hitran
sf.fetch_databank("hitran", memory_mapping_engine='vaex', output='pandas', load_columns="all")
df_pandas = sf.df0

sf.fetch_databank("hitran", memory_mapping_engine='vaex', output='vaex', load_columns="all")
df_vaex = sf.df0

assert df_vaex[0][0] == df_pandas.iloc[0]["wav"]

columns_vaex = df_vaex.column_names
columns_pandas = df_pandas.column
comparison = (df_vaex.column_names == df_pandas.columns)

assert comparison.all()

# Testing Hitemp
sf.fetch_databank("hitemp", memory_mapping_engine='vaex', output='pandas', load_columns="all")
df_pandas = sf.df0

sf.fetch_databank("hitemp", memory_mapping_engine='vaex', output='vaex', load_columns="all")
df_vaex = sf.df0

assert df_vaex[0][0] == df_pandas.iloc[0]["wav"]

columns_vaex = df_vaex.column_names
columns_pandas = df_pandas.column
comparison = (df_vaex.column_names == df_pandas.columns)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id="refactoring-the-code-to-calculate-the-spectrum-using-vaex-dataframe"&gt;Refactoring the code to calculate the Spectrum using Vaex dataframe&lt;/h4&gt;

&lt;p&gt;To calculate the spectrum using the Vaex dataframe ,I had to made changes to the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;radis/api/hitranapi.py&lt;/li&gt;
&lt;li&gt;radis/api/cdsdapi.py&lt;/li&gt;
&lt;li&gt;radis/api/hdf5.py&lt;/li&gt;
&lt;li&gt;radis/api/cache_files.py&lt;/li&gt;
&lt;li&gt;radis/api/tools.py&lt;/li&gt;
&lt;li&gt;radis/io/exomol.py&lt;/li&gt;
&lt;li&gt;radis/io/geisa.py&lt;/li&gt;
&lt;li&gt;radis/io/hitran.py&lt;/li&gt;
&lt;li&gt;radis/io/query.py&lt;/li&gt;
&lt;li&gt;radis/lbl/base.py&lt;/li&gt;
&lt;li&gt;radis/lbl/broadening.py&lt;/li&gt;
&lt;li&gt;radis/lbl/calc.py&lt;/li&gt;
&lt;li&gt;radis/lbl/loader.py&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are all files which are involved in calculating the Spectrum of molecule(s) ,from loading to calculating . I have only refactord the part that is required to Equilibrium Calculations .I kept the previous implementation of Pandas and just added code for Vaex .&lt;/p&gt;

&lt;p&gt;For loading the main changes are done in hitranapi.py for parsing the molecules and i also had to spend a lot time on it to find the equivalent operations functions in Vaex as in Pandas .
Finally , i was able to resolve the issue and below is final code that worked for me .&lt;/p&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;def _parse_HITRAN_class1(df, verbose=True,dataframe_type="pandas"):
r"""Diatomic molecules: CO, HF, HCl, HBr, HI, N2, NO+


Parameters
----------
df: pandas Dataframe
lines read from a HITRAN-like database


Notes
-----
HITRAN syntax [1]_ :

&amp;gt;&amp;gt;&amp;gt;       v
&amp;gt;&amp;gt;&amp;gt;  13x I2

References
----------

.. [1] `Table 3 of Rothman et al. HITRAN 2004 &amp;lt;https://www.cfa.harvard.edu/hitran/Download/HITRAN04paper.pdf&amp;gt;`__


"""

if dataframe_type == "vaex":
# 1. Parse

extracted_values = df['globu'].str.extract_regex(pattern = r"[ ]{13}(?P&amp;lt;vu&amp;gt;[\d ]{2})")
df['vu'] = extracted_values.apply(lambda x : x.get('globu'))
df['vu'] = df.evaluate(df['vu'])

extracted_values = df['globl'].str.extract_regex(pattern = r"[ ]{13}(?P&amp;lt;vl&amp;gt;[\d ]{2})")
df['vl'] = extracted_values.get(df['globl'])
df['vl'] = df.evauate(df['vl'])

# 2. Convert to numeric
cast_to_int64_with_missing_values(df, ["vu" ,"vl"], dataframe_type=dataframe_type)

# 3. Clean
del df["globu"]
del df["globl"]

return df
elif dataframe_type == "pandas":
# 1. Parse
dgu = df["globu"].astype(str).str.extract(r"[ ]{13}(?P&amp;lt;vu&amp;gt;[\d ]{2})", expand=True)
dgl = df["globl"].astype(str).str.extract(r"[ ]{13}(?P&amp;lt;vl&amp;gt;[\d ]{2})", expand=True)

# 2. Convert to numeric
cast_to_int64_with_missing_values(dgu, ["vu"],dataframe_type=dataframe_type)
cast_to_int64_with_missing_values(dgl, ["vl"],dataframe_type=dataframe_type)

# 3. Clean
del df["globu"]
del df["globl"]

return pd.concat([df, dgu, dgl], axis=1)
else:
raise NotImplementedError(dataframe_type)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For other part of the code , i added an additional parameter self.dataframe_type and whenever operations are different for vaex and pandas ,I used it to execute the part of code for the respective dataframe type as whether it is Vaex or Pandas .&lt;/p&gt;

&lt;p&gt;#####Spectrum using Vaex and Pandas&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code used&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-plaintext highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;from radis import calc_spectrum

s, factory_s = calc_spectrum(1800, 2500,         # cm-1
molecule='H2O',
isotope='1,2,3',
pressure=1.01325,   # bar
Tgas=700,           # K
mole_fraction=0.1,
path_length=1,      # cm
databank='hitemp',  # or 'hitemp', 'geisa', 'exomol'
wstep='auto',
use_cached=False,
engine='vaex',
return_factory=True,
)

s.apply_slit(0.5, 'nm')       # simulate an experimental slit
s.plot('radiance')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id="using-vaex"&gt;Using Vaex&lt;/h6&gt;
&lt;p&gt;&lt;img alt="spectrum using vaex" src="https://1someshverma.github.io/images/specturm-using-vaex.png"&gt;&lt;/p&gt;

&lt;h6 id="using-pandas"&gt;Using Pandas&lt;/h6&gt;
&lt;p&gt;As i also kept the Pandas implementation , spectrum calculated using that is&lt;/p&gt;

&lt;p&gt;&lt;img alt="spectrum using pandas" src="https://1someshverma.github.io/images/specturm-using-vaex.png"&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230616_0000_1someshverma/</guid><pubDate>Thu, 15 Jun 2023 23:00:00 GMT</pubDate></item><item><title>GSOC Week 1¬†: A global overview of the RADIS API.</title><link>http://openastronomy.org/Universe_OA/posts/2023/06/20230604_2227_menasrac/</link><dc:creator>Racim MENASRIA</dc:creator><description>&lt;h4&gt;GSOC Week 1¬†: A global overview of the RADIS¬†API.&lt;/h4&gt;&lt;p&gt;Since the point of my project is to implement new databases in the RADIS API and to reform it in other to make it common and stand alone, it seems important to understand how this API¬†works.&lt;/p&gt;
&lt;p&gt;Thus, I have started my 12 weeks projects by reading carefully the API documentation available at &lt;a href="https://radis.readthedocs.io/en/latest/source/radis.io.dbmanager.html"&gt;https://radis.readthedocs.io/en/latest/source/radis.io.dbmanager.html&lt;/a&gt;. I will detail in this article what I consider the key points to understand how Radis works globally and aim to answer the following question¬†: Whats are the steps to proceed in order to include a new database as Kurucz to RADIS¬†?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This page is a description of the different modules available in the RADIS library except the api one which will be discussed later.&lt;/strong&gt;&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1017/1*UPlH0eBh97WoVpiEn_C7rQ.png"&gt;&lt;/figure&gt;&lt;p&gt;In particular, the radis.io package provided functionality for file management, downloading and analysis of different spectroscopic databases.&lt;/p&gt;
&lt;p&gt;To understand in detail how the RADIS API works and integrate a new database like Kurucz, here are the most important radis.io package sub-modules to explore¬†:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dbmanager&lt;/strong&gt;¬†: This submodule used to contain the DatabaseManager class, which is the heart of database management in RADIS before it was moved to the api module. Understanding how this class is used to save, download, manipulate and interact with existing databases is essential. I will also need to understand how to add a new database by implementing the appropriate methods.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;geisa, hitran or exomol¬†: &lt;/strong&gt;I have to study how GEISA, HITRAN or Exomol files are downloaded, saved and processed. Understanding how this databases are integrated will give me an idea of the structure and workflow needed to integrate a new database.&lt;/p&gt;
&lt;h4&gt;The DatabaseManager class&lt;/h4&gt;&lt;p&gt;The DatabaseManager class aims to handle and manage files from various databases. It provides a generic framework for managing and caching files from different sources or databases.&lt;/p&gt;
&lt;pre&gt;class DatabaseManager(object):&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;add_column(df, key, value)&lt;/strong&gt;: This method allows to create a column with a key and a value specified in a DataFrame or a dictionary.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;check_deprecated_files(local_files, auto_remove=True)&lt;/strong&gt;: This method checks file metadata and removes deprecated ones. If auto_remove is set to True, deprecated files will be automatically removed. Otherwise, an error will be¬†thrown.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clean_download_files()&lt;/strong&gt;: This method cleans downloaded and unzipped¬†files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;download_and_parse(urlnames, local_files)&lt;/strong&gt;: This method downloads and parses files from the specified URLs and saves them¬†locally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fetch_filenames()&lt;/strong&gt;: This method fetches the names of all files from the database, even if they haven‚Äôt been downloaded yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fetch_urlnames()&lt;/strong&gt;: This method must be overridden in the DatabaseManager subclass. It should return a list of URLs corresponding to database¬†files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get_columns(local_file)&lt;/strong&gt;: This method retrieves all the columns available in a database file using the get_columns function of the DataFileManager class.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;load(local_files, columns=None, lower_bound=[], upper_bound=[], within=[], output=‚Äôpandas‚Äô):&lt;/strong&gt; This method loads data from database files. You can specify which columns to load, lower and upper bounds for values in certain columns, and constraints for certain columns. You can also specify the output format, such as ‚Äòpandas‚Äô, ‚Äòvaex‚Äô or¬†‚Äòjax‚Äô.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;plot(local_files, isotope, wavenum_min, wavenum_max):&lt;/strong&gt; This method is a convenience function for plotting the linestrengths of the database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;register(dict_entries):&lt;/strong&gt; This method registers dictionary entries for a specified database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove_local_files(local_files)&lt;/strong&gt;: This method removes the specified local¬†files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rename_columns(df, rename_dict):&lt;/strong&gt; This method renames the columns of a DataFrame using a dictionary of correspondence between the old column names and the new¬†names.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;register_database(databank_name, dict_entries, verbose): &lt;/strong&gt;This method adds registered databases to the RADIS configuration file.&lt;/p&gt;
&lt;h4&gt;The radis.io.geisa module review¬†: to get some ideas¬†?&lt;/h4&gt;&lt;p&gt;The GEISADatabaseManager class is a subclass of DatabaseManager which is specifically designed to manage GEISA databases. It adds specific functionalities to the management of GEISA files and their integration into the RADIS API. It gives us an insight of what the implemenation of other databases as Kurucz should look like. However, every database has its own specificities that is why the methods may differ on some aspects though they are built on a same¬†basis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fetch_urlnames(): &lt;/strong&gt;This method must be implemented to return a list of URLs corresponding to GEISA files in your database. These URLs will be used to download files from the GEISA¬†website.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parse_to_local_file():&lt;/strong&gt; This method is used to unpack GEISA files and save them locally. It also adds metadata to¬†files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;register():&lt;/strong&gt; This method registers the GEISA database in the RADIS configuration file. It ensures that the RADIS API recognizes and can access the database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fetch_geisa():&lt;/strong&gt; This GEISA specific method fetches GEISA files from the GEISA website, unpacks them and creates an HDF5 file containing all row data. It returns a Pandas DataFrame containing all¬†rows.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;columns_GEISA:&lt;/strong&gt; It is a dictionary that defines the parsing order of columns in the GEISA2020 format. It specifies column names, data types, descriptions, and¬†units.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;engine:&lt;/strong&gt; This is an optional parameter that allows to specify the memory mapping library to use for the GEISA database. By default, it uses the ‚Äòdefault‚Äô value specified in the RADIS configuration file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;verbose, chunksize, parallel:&lt;/strong&gt; These are optional parameters to control the verbosity level of informational messages, the size of chunks for loading data and the use of parallel¬†loading.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The fetch_geisa() &lt;/strong&gt;method is an example of using the GEISADatabaseManager class to retrieve GEISA data for a specific molecule. This method downloads GEISA files from the GEISA website, unpacks them and saves them locally. It returns a Pandas DataFrame containing all rows from the GEISA database for the specified molecule.&lt;/p&gt;
&lt;p&gt;Before exploring the Kurucz database structure more in details, let is discuss the other modules of the RADIS¬†API.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;The db module¬†:&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Definition of molecules:&lt;/strong&gt; The db module allows to define the molecules used in the spectroscopic calculations. You can specify isotopes, molecular weights, chemical symbols, and other relevant molecular properties.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spectroscopic constants: &lt;/strong&gt;The db module stores the spectroscopic constants associated with each molecule, such as electronic transitions, energy levels, frequencies, absorption intensities, cross sections, etc.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data Access&lt;/strong&gt;: The db module provides methods and data structures to easily access information about molecules and spectroscopic constants.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Database extensions:&lt;/strong&gt; The db module allows extending the functionalities of the database by adding new molecules, isotopes or spectroscopic constants. Here it is possible to add new data or integrate external databases to enrich the capabilities of¬†RADIS.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interoperability:&lt;/strong&gt; The db module facilitates interoperability with other libraries and spectroscopic data formats. It allows to import and export spectroscopic data in different formats, such as HITRAN, HITEMP, GEISA, Kurucz,¬†etc.&lt;/p&gt;
&lt;h4&gt;What about Exojax¬†?&lt;/h4&gt;&lt;p&gt;Another open-source code, called EXOJAX, exchanged portions of code with RADIS until some parts of both codes became very similar. Currently, a database API is written in the RADIS¬†code.&lt;/p&gt;
&lt;p&gt;Understanding how Radis and Exojax somehow partially merged will be useful to understand how to implement a new database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;May 2022¬†&lt;/strong&gt;: an example of an Exojax-like syntax was added in the exomol.py file. This example introduces a new class called mdbExomol, which holds Jax arrays as attributes. This class is based on DataFrame loading and is designed to be a drop-in replacement for Exojax computations.&lt;/p&gt;
&lt;pre&gt;mport pathlib&lt;br&gt;&lt;br&gt;import numpy as np&lt;br&gt;&lt;br&gt;from radis.api.exomolapi import (&lt;br&gt;    MdbExomol,&lt;br&gt;    get_exomol_database_list,&lt;br&gt;    get_exomol_full_isotope_name,&lt;br&gt;)&lt;br&gt;from radis.db.classes import get_molecule_identifier&lt;br&gt;&lt;br&gt;&lt;br&gt;def fetch_exomol(&lt;br&gt;    molecule,&lt;br&gt;    database=None,&lt;br&gt;    local_databases=None,&lt;br&gt;    databank_name="EXOMOL-{molecule}",&lt;br&gt;    isotope="1",&lt;br&gt;    load_wavenum_min=None,&lt;br&gt;    load_wavenum_max=None,&lt;br&gt;    columns=None,&lt;br&gt;    cache=True,&lt;br&gt;    verbose=True,&lt;br&gt;    clean_cache_files=True,&lt;br&gt;    return_local_path=False,&lt;br&gt;    return_partition_function=False,&lt;br&gt;    engine="default",&lt;br&gt;    output="pandas",&lt;br&gt;    skip_optional_data=True,&lt;br&gt;):&lt;/pre&gt;&lt;p&gt;Here is a description of each function parameter:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;molecule&lt;/strong&gt;: The name of the molecule for which we want to retrieve data.&lt;br&gt;database: The name of the specific ExoMol database to use. If the value is None or ‚Äúdefault‚Äù, the recommended database will be used.&lt;br&gt;local_databases: The path to the local directory where the ExoMol database files will be stored.&lt;br&gt;&lt;strong&gt;databank_name:&lt;/strong&gt; The name to give to the ExoMol database.&lt;br&gt;isotope: The number of the specific isotope of the molecule for which you want to retrieve data.&lt;br&gt;&lt;strong&gt;load_wavenum_min and load_wavenum_max:&lt;/strong&gt; The minimum and maximum wavenumbers to load.&lt;br&gt;&lt;strong&gt;columns: &lt;/strong&gt;A list of specific columns to load from ExoMol files.&lt;br&gt;&lt;strong&gt;cache:&lt;/strong&gt; A boolean indicating whether files should be cached for later use.&lt;br&gt;&lt;strong&gt;verbose:&lt;/strong&gt; A boolean indicating whether informational messages should be displayed during the process.&lt;br&gt;&lt;strong&gt;clean_cache_files:&lt;/strong&gt; A boolean indicating whether cached files should be removed after use.&lt;br&gt;&lt;strong&gt;return_local_path and return_partition_function:&lt;/strong&gt; Booleans indicate whether local path to files and partition function should be returned in addition to¬†data.&lt;/p&gt;
&lt;p&gt;The function starts by checking the settings and determining which ExoMol database to use. Next, it creates an MdbExomol object to manage the ExoMol database, downloading files as needed. The local files are then loaded into a DataFrame, with specific columns if needed. RADIS-specific manipulations are performed on the DataFrame, such as renaming columns and adding additional data. Eventually the DataFrame is returned, possibly with other information if selected.&lt;/p&gt;
&lt;p&gt;Then &lt;a href="https://medium.com/u/1169335fca8"&gt;Erwan Pannier&lt;/a&gt; added an Example of an Exojax-like syntax, creating a ``mdbExoMol` class holding jax arrays as Attributes (based on DataFrame loading), so it can be used as a drop-in replacement&lt;/p&gt;
&lt;p&gt;The example also shows how to¬†: Compute an Exomol CH4 spectrum with Radis Load Exomol CH4 Jax arrays ready for an Exojax computation, by downloading the files to the¬†.database local folder Load Exomol CH4 Jax arrays ready for an Exojax computation, by loading the files from the Radis‚Äôs database of (1) For 2. and 3., a local_databases= parameter allows to easily switch in between any local folder (to save on download &amp;amp; caching times if comparing the two¬†codes)&lt;/p&gt;
&lt;p&gt;Here is the code ( available on &lt;a href="https://github.com/radis/radis/blob/e317c994451d3afa02b1fa63d90ae0eb546f36ed/radis/io/exomol.py#L925"&gt;radis/exomol.py at e317c994451d3afa02b1fa63d90ae0eb546f36ed ¬∑ radis/radis (github.com)&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;   #%% RADIS-like Example&lt;br&gt;    # uses fetch_exomol() internally&lt;br&gt;&lt;br&gt;    from radis import calc_spectrum&lt;br&gt;&lt;br&gt;    s = calc_spectrum(&lt;br&gt;        wavelength_min=1.630e4,&lt;br&gt;        wavelength_max=1.6305e4,&lt;br&gt;        molecule="CH4",&lt;br&gt;        isotope="1",&lt;br&gt;        pressure=1.01325,  # bar&lt;br&gt;        Tgas=1000,  # K&lt;br&gt;        mole_fraction=0.1,&lt;br&gt;        path_length=1,  # cm&lt;br&gt;        # broadening_method="fft",  # @ dev: Doesn't work with 'voigt'&lt;br&gt;        databank=(&lt;br&gt;            "exomol",&lt;br&gt;            "YT10to10",&lt;br&gt;        ),  # Simply use 'exomol' for the recommended database&lt;br&gt;    )&lt;br&gt;    # s.apply_slit(1, "cm-1")  # simulate an experimental slit&lt;br&gt;    s.plot("xsection")&lt;br&gt;&lt;br&gt;    # %% Exojax like Example&lt;br&gt;&lt;br&gt;    class mdbExoMol:&lt;br&gt;&lt;br&gt;        # hardcode attribute names, to prevent typos and the declaration of unwanted parameters&lt;br&gt;        __slots__ = [&lt;br&gt;            "Sij0",&lt;br&gt;            "logsij0",&lt;br&gt;            "nu_lines",&lt;br&gt;            "A",&lt;br&gt;            "elower",&lt;br&gt;            "eupper",&lt;br&gt;            "gupper",&lt;br&gt;            "jlower",&lt;br&gt;            "jupper",&lt;br&gt;        ]&lt;br&gt;&lt;br&gt;        def __init__(&lt;br&gt;            self,&lt;br&gt;            molecule,&lt;br&gt;            path,&lt;br&gt;            nurange=[-np.inf, np.inf],&lt;br&gt;            crit=-np.inf,&lt;br&gt;            local_databases="~/exojax",&lt;br&gt;        ):&lt;br&gt;            """&lt;br&gt;            Parameters&lt;br&gt;            ----------&lt;br&gt;            molecule: molecule name&lt;br&gt;            path : local path, mirror of ExoMol path&lt;br&gt;            nurange : TYPE, optional&lt;br&gt;                DESCRIPTION. The default is [-np.inf, np.inf].&lt;br&gt;            crit : TYPE, optional&lt;br&gt;                DESCRIPTION. The default is -np.inf.&lt;br&gt;&lt;br&gt;            Returns&lt;br&gt;            -------&lt;br&gt;            DataFrame&lt;br&gt;&lt;br&gt;            Examples&lt;br&gt;            --------&lt;br&gt;            ::&lt;br&gt;&lt;br&gt;                mdbCH4 = mdbExoMol("CH4", '.database/CH4/12C-1H4/YT10to10/', nus, crit=1.e-30)&lt;br&gt;                print(len(mdbCH4.nu_lines), "lines")&lt;br&gt;                mdbCH4.elower&lt;br&gt;&lt;br&gt;            Available columns::&lt;br&gt;&lt;br&gt;                [&lt;br&gt;                    "Sij0",&lt;br&gt;                    "logsij0",&lt;br&gt;                    "nu_lines",&lt;br&gt;                    "A",&lt;br&gt;                    "elower",&lt;br&gt;                    "eupper",&lt;br&gt;                    "gupper",&lt;br&gt;                    "jlower",&lt;br&gt;                    "jupper",&lt;br&gt;                ]&lt;br&gt;&lt;br&gt;            """&lt;br&gt;&lt;br&gt;            wavenum_min, wavenum_max = np.min(nurange), np.max(nurange)&lt;br&gt;            if wavenum_min == -np.inf:&lt;br&gt;                wavenum_min = None&lt;br&gt;            if wavenum_max == np.inf:&lt;br&gt;                wavenum_max = None&lt;br&gt;&lt;br&gt;            # Set-up database, download files and set-up cache files if needed&lt;br&gt;            mdb = MdbExomol(&lt;br&gt;                path,&lt;br&gt;                molecule=molecule,&lt;br&gt;                local_databases=local_databases,&lt;br&gt;                nurange=[wavenum_min, wavenum_max],&lt;br&gt;            )&lt;br&gt;&lt;br&gt;            # Get cache files to load :&lt;br&gt;            mgr = mdb.get_dframe_manager()&lt;br&gt;            local_files = [mgr.cache_file(f) for f in mdb.trans_file]&lt;br&gt;&lt;br&gt;            # Load them:&lt;br&gt;            jdict = mdb.load(&lt;br&gt;                local_files,&lt;br&gt;                columns=[k for k in self.__slots__ if k not in ["logsij0"]],&lt;br&gt;                lower_bound=([("nu_lines", wavenum_min)] if wavenum_min else [])&lt;br&gt;                + ([("Sij0", mdb.crit)] if not np.isneginf(mdb.crit) else []),&lt;br&gt;                upper_bound=([("nu_lines", wavenum_max)] if wavenum_max else []),&lt;br&gt;                output="jax",&lt;br&gt;            )&lt;br&gt;&lt;br&gt;            # set attributes, accessible as e.g:  mdb.nu_lines&lt;br&gt;            for k in jdict.keys():&lt;br&gt;                setattr(self, k, jdict[k])&lt;br&gt;&lt;br&gt;    nus = np.linspace(1e7 / 1.630e4, 1e7 / 1.6305e4)&lt;br&gt;&lt;br&gt;    # Download new ExoMol repo (in ~/exomol)&lt;br&gt;    mdbCH4 = mdbExoMol(&lt;br&gt;        "CH4",&lt;br&gt;        ".database/CH4/12C-1H4/YT10to10/",&lt;br&gt;        nus,&lt;br&gt;        crit=1.0e-30,&lt;br&gt;        local_databases=".",  # use local folder&lt;br&gt;    )&lt;br&gt;&lt;br&gt;    print(len(mdbCH4.nu_lines), "lines")&lt;br&gt;    mdbCH4.elower&lt;br&gt;&lt;br&gt;    # Or use RADIS's folder  (# by default ~/.radisdb/exomol)&lt;br&gt;    import radis&lt;br&gt;&lt;br&gt;    mdbCH4_2 = mdbExoMol(&lt;br&gt;        "CH4",&lt;br&gt;        "CH4/12C-1H4/YT10to10/",&lt;br&gt;        nus,&lt;br&gt;        crit=1.0e-30,&lt;br&gt;        local_databases=pathlib.Path(radis.config["DEFAULT_DOWNLOAD_PATH"]) / "exomol",&lt;br&gt;    )&lt;br&gt;    # ... ready to run Jax calculations&lt;/pre&gt;&lt;p&gt;The example added in the exomol.py file of RADIS demonstrates how to create an ‚ÄúmdbExoMol‚Äù class similar to Exojax, which uses jax arrays as attributes. This class allows loading ExoMol data as jax arrays, making them compatible with¬†Exojax.&lt;/p&gt;
&lt;p&gt;The example illustrates how to calculate a CH4 spectrum using RADIS by utilizing the ‚ÄúmdbExoMol‚Äù class. It also shows how to load the jax arrays ready for use in an Exojax computation by downloading the files into a local ‚Äú.database‚Äù folder. Additionally, the example demonstrates how to load the jax arrays from the RADIS database, enabling easy switching between different local databases by specifying the ‚Äúlocal_databases‚Äù parameter.&lt;/p&gt;
&lt;h4&gt;Toward a common API¬†?&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Preliminary work in Radis¬†#465&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This preliminary work was done to prepare for a meeting between RADIS and ExoJax to discuss the implementation of a common API for database management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The rationale behind this work is to maintain three layers of agnosticism to simplify the user experience:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Users should not have to worry about the specific format of the input database,&lt;/strong&gt; such as HITRAN 2012, HITRAN 2020, HITEMP, GEISA, ExoMol, Kuruz, NIST, etc. This allows for easy integration of new libraries and ensures that all codes can benefit from all available libraries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Users should not have to be concerned about the format in which the data is stored on disk&lt;/strong&gt;, whether it‚Äôs Vaex‚Äôs HDF5, Pandas‚Äôs HDF5, Feather, or other formats. This flexibility enables the switch to more performant libraries when they become available, such as¬†PyArrow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Users should have the freedom to choose the output format used in calculations&lt;/strong&gt;, whether it‚Äôs Pandas‚Äôs DataFrame, Jax arrays, Vaex DataFrame, or others. This allows for data retrieval in the desired format for each code, such as Jax for ExoJax, Pandas for the current RADIS implementation, or Vaex for future fully-out-of-core RADIS for extreme databases.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Radis state in May¬†2022&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;ExoJax &lt;/strong&gt;has MdbExomol or MdbHIt¬†. They are similar but don‚Äôt inherit from a common base¬†;&lt;br&gt;&lt;strong&gt;RADIS 0.12 has a DatabaseManager&lt;/strong&gt; to handle HITEMP 2020 / HITRAN 2020; the ExoMol support is done with a MdBMol taken from Exojax with no link with the DatabaseManager.&lt;br&gt;RADIS implemented a &lt;strong&gt;DataFileManager&lt;/strong&gt; &lt;strong&gt;class&lt;/strong&gt; to handle (Vaex‚Äôs HDF5; Pandas‚Äôs HDF5, Feather)¬†; DatabaseManager calls DataFileManager internally &lt;br&gt;Radis Exomol api update #464 added &lt;strong&gt;3 output¬†: ‚Äôjax/vaex/pandas‚Äô&lt;/strong&gt; to RADIS‚Äôs DatabaseManager&lt;/p&gt;
&lt;p&gt;Here Radis then suggest a code a demonstration¬†:&lt;/p&gt;
&lt;pre&gt;# Test ExoMol&lt;br&gt;&lt;br&gt;import radis&lt;br&gt;radis.config["MEMORY_MAPPING_ENGINE"] = "vaex" # üëâüëâüëâ  choose  "vaex", "pytables", "feather"&lt;br&gt;&lt;br&gt;from radis.io.exomol import fetch_exomol&lt;br&gt;&lt;br&gt;df = fetch_exomol("SiO", database="EBJT", isotope="1", load_wavenum_max=5000, &lt;br&gt;        output="pandas" # üëâüëâüëâ choose : "pandas", "vaex", "jax"&lt;br&gt;        )&lt;br&gt;print(df)&lt;br&gt;&lt;br&gt;&lt;/pre&gt;&lt;p&gt;This code allows you to fetch ExoMol data for the SiO molecule from the specified database, control the output format, and print the resulting DataFrame.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;MdbExomol class&lt;/strong&gt; is a molecular database class specifically designed for ExoMol, which is a database of molecular line lists for exoplanet and other hot atmospheres. It is a subclass of the DatabaseManager class.&lt;/p&gt;
&lt;p&gt;The MdbExomol class has the following parameters:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;path&lt;/strong&gt;: The path for the ExoMol data directory or tag.&lt;br&gt;nurange: A wavenumber range list (in cm-1) or a wavenumber array.&lt;br&gt;margin: A margin for the wavenumber range (in cm-1).&lt;br&gt;&lt;strong&gt;crit:&lt;/strong&gt; The line strength lower limit for extraction.&lt;br&gt;&lt;strong&gt;bkgdatm&lt;/strong&gt;: The background atmosphere for broadening, e.g., H2, He.&lt;br&gt;broadf: If False, the default broadening parameters in the¬†.def file are used.&lt;br&gt;Additionally, there are other parameters such as engine and skip_optional_data that control the memory mapping engine and the loading of optional data from the ExoMol definition file, respectively.&lt;/p&gt;
&lt;p&gt;The MdbExomol class provides methods to load and manage the ExoMol data files. It converts the trans/states files to feather or HDF5 format for efficient loading. The loaded data is stored in a DataFrame with columns such as nu_lines, Sij0, A, elower, gpp, jlower, and more. These columns contain information about line centers, line strengths, Einstein A coefficients, lower state energy, statistical weight, J_lower, and other relevant parameters.&lt;/p&gt;
&lt;p&gt;The class also provides examples of how to initialize the database, download the necessary files, and load the data. It references the original publications on ExoMol for more information.&lt;/p&gt;
&lt;h5&gt;Discussion between Radis and¬†Exojax&lt;/h5&gt;&lt;p&gt;The question of hosting the common API was addressed for the first time in discussion&lt;strong&gt; #257&lt;/strong&gt;. It is suggested to create a new directory or module within Radis for the common API. However, it is noted that this may make development difficult if specific Radis features need to be integrated into the common API. A suggestion is made to create a separate module, such as ‚Äúradis.api‚Äù, which would house the common¬†API.&lt;/p&gt;
&lt;p&gt;A proposed structure was discussed, where the DatabaseManager class is considered the core common API. Subclasses, such as HitranManager and ExomolManager, inherited from DatabaseManager to provide the specific functionalities for the Hitran and Exomol databases, respectively.&lt;/p&gt;
&lt;p&gt;A suggestion was made to create a MdbHitran class (inheriting from HitranManager) and a MdbExomol class (inheriting from ExomolManager) for the ExoJAX API. These classes would have their own ExoJAX-specific methods, allowing ExoJAX to integrate with the common¬†API.&lt;/p&gt;
&lt;p&gt;Radis and Exojax agreed that separating the functionalities into separate folders is a good approach to avoid conflicts between Radis-specific and ExoJAX-specific features. Additionally, they suggested to add tests to ensure that ExoJAX requirements were tested within Radis without causing any¬†issues.&lt;/p&gt;
&lt;p&gt;It starts from the ‚Äúradis.api‚Äù folder for the common API, which would be included within Radis. This approach would allow for the development of the common API while maintaining a close connection with Radis. Furthermore, the possibility of creating a new directory or module for an independent API in the future is considered, to allow the common API to become independent if¬†needed.&lt;/p&gt;
&lt;p&gt;In summary, the conversation revolves around the hosting and structure of the common API between Radis and ExoJAX. It is decided to create a separate module, ‚Äúradis.api‚Äù, for the common API while keeping the possibility of independent development in the future. Specific classes are proposed for ExoJAX, enabling the integration of ExoJAX into the common API. Measures are taken to separate Radis-specific and ExoJAX-specific functionalities and to test ExoJAX requirements within¬†Radis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After this discussion, a series of measures was implemented to Radis in PR #¬†480&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The common functions shared between Exojax and Radis were moved to the &lt;strong&gt;‚Äúradis/api‚Äù&lt;/strong&gt; directory, allowing for better organization and separation of concerns.&lt;br&gt;Parts of Hitran, Hitemp, CDSD, and GEISA &lt;strong&gt;that were common to both Exojax and Radis were also moved to the ‚Äúradis/api‚Äù&lt;/strong&gt; directory.&lt;br&gt;The Exomol files were combined and moved to the ‚Äúradis/api‚Äù directory, and tests were fixed accordingly.&lt;br&gt;The io.tools module was moved to the ‚Äúradis/api/tools‚Äù directory for better organization.&lt;br&gt;Links in the documentation and docstrings were renamed to reflect the changes in the code structure.&lt;br&gt;Some missing files were added, isort errors on CI were fixed, and unclosed HDF5 files were addressed.&lt;br&gt;The Exomol documentation was updated, and error messages were improved.&lt;br&gt;The set_broadenings function was made compatible with both vaex and pandas DataFrames.&lt;br&gt;Modifications were made to the set_broadening function, including assuming a dictionary as input for unknown DataFrames and redefining the function to store values in a DataFrame.&lt;br&gt;The MdbExomol instance now includes self.molmass.&lt;br&gt;The codebase was merged with the upstream ‚Äúadd/common-api‚Äù branch.&lt;br&gt;Some abspath problems were fixed, and error messages were improved.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In November 2022, the version 0.14 was released and the common API with Exojax was added to¬†Radis.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Review of the exomolapi.py code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This code is an API for accessing and using data from the ExoMol project. It includes a main class MdbExomol that allows downloading and accessing ExoMol files, as well as performing spectral calculations. The MdbExomol class provides methods for downloading files, creating PartFuncExoMol objects, and loading specific line¬†data.&lt;/p&gt;
&lt;p&gt;The download function allows downloading ExoMol files from a specified URL and saving them locally. The to_partition_function_tabulator function generates a PartFuncExoMol object from the ExoMol-specific partition function¬†data.&lt;/p&gt;
&lt;p&gt;The if __name__ == ‚Äú__main__‚Äù section contains examples of using the MdbExomol class and other features of the API, including spectrum calculations using the RADIS library, and downloading and accessing ExoMol line data using the fetch_exomol function.&lt;/p&gt;
&lt;p&gt;Thus, the ExoMol API provides tools for downloading, manipulating, and utilizing spectroscopic data from the ExoMol project, including transition files, partition functions, and calculated spectra.&lt;/p&gt;
&lt;h4&gt;Conclusion¬†: How should I proceed to add to Radis a new database as Kurucz¬†?&lt;/h4&gt;&lt;p&gt;Regarding implementing Kurucz, the structure of the exomolapi.py code can serve as a model for building a similar API for Kurucz data. I may create a class similar to MdbExomol that handles downloading Kurucz files, accessing the relevant data (such as atomic and molecular line data, partition functions, etc.), and provides methods for spectral calculations and other functionalities specific to Kurucz. I will have to adapt and modify the existing code to suit the data format and organization of Kurucz data.&lt;br&gt;In order to do so, I will review the structure of the Kurucz database and make a quick report in a next post before starting the implementation.&lt;/p&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=fc58bc4e9979" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/06/20230604_2227_menasrac/</guid><pubDate>Sun, 04 Jun 2023 21:27:53 GMT</pubDate></item><item><title>Utilising community bonding period Effectively!</title><link>http://openastronomy.org/Universe_OA/posts/2023/05/20230530_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;I started to contribute to RADIS from January‚Äô23 and whenever i needed help in some issue , mentors were quite helpful in providing revelant information to resolve that issue . And this thing helped me , to develop good bonding and understanding with the mentors .&lt;/p&gt;

&lt;p&gt;So,I thought, i should use community bonding period more productively thus, i decided to work on project from 15 May .&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;In community bonding period i have done following things -&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read the RADIS and HITRAN Paper (selected parts)&lt;/li&gt;
&lt;li&gt;Worked on Loading the dataframe in Vaex format (task of first week)&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id="loading-dataframe-in-vaex-format"&gt;Loading Dataframe in Vaex format&lt;/h6&gt;
&lt;p&gt;There are two main functions which are used load databank in RADIS
These are :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fetch_databank()&lt;/li&gt;
&lt;li&gt;load_databank()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fetch_databank() : It is used to load databank from standard databank like HITRAN,HITEMP,EXOMOL,GEISA by fetching it from their respective APIs, then parsing and processing them.&lt;/p&gt;

&lt;p&gt;load_databank() : It is used to load databank from the local file or to load databank from user defined databank .&lt;/p&gt;

&lt;p&gt;Upto now, i have worked on fetch_databank() function to load dataframe in Vaex format , some of the things were already implemented while at other points i needed to write code specifically for vaex dataframe format.&lt;/p&gt;

&lt;p&gt;Similarly, for load_databank() function , the hurdle was to parse it in vaex dataframe format as virual columns which are used in vaex dataframe to reduce memory use , it was throwing error . After trying many i finally found a fix for it .&lt;/p&gt;

&lt;p&gt;Now, I have made necessary changes to these two functions to load dataframe in Vaex format. Next week i will be working on writing test cases for these.&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/05/20230530_0000_1someshverma/</guid><pubDate>Mon, 29 May 2023 23:00:00 GMT</pubDate></item><item><title>Getting selected for GSoC‚Äô23@RADIS!</title><link>http://openastronomy.org/Universe_OA/posts/2023/05/20230524_0000_1someshverma/</link><dc:creator>Somesh Verma</dc:creator><description>&lt;p&gt;I am Somesh Verma,a third year undergrad at National Institute of Technology Hamirpur. I have been accepted as contributor to the OpenAstronomy  RADIS.&lt;/p&gt;

&lt;h4 id="choosing-organisation"&gt;Choosing Organisation&lt;/h4&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;I  chose OpenAstronomy as i have interest in astronomy right from my childhood and RADIS also aline with my interst and skills .I have also contributed to Libre Health App for Baby Care but then i shifted my focus  only to RADIS . By the end i had four merged pull request and I was working on the fifth issue.&lt;/p&gt;

&lt;h4 id="contriutions-and-experience"&gt;Contriutions and Experience&lt;/h4&gt;
&lt;p&gt;I started to contribute to RADIS from January‚Äô23 , initially i faced problem to set up the things and run the code . After one weel or so I fixed the issues and than I spent one week on understanding the codebase ,reading documentation and try examples. By now , i had developed a rough understanding of the code .&lt;/p&gt;

&lt;p&gt;Then , I started to find issue over which i can work and started to work on the issues ,mentors have been quite helpful so far, whenever i got struck somewhere ,they helped in resolving the issue .&lt;/p&gt;

&lt;p&gt;I am looking forward to have the great Learning experience this Summer with RADIS :)&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/05/20230524_0000_1someshverma/</guid><pubDate>Tue, 23 May 2023 23:00:00 GMT</pubDate></item><item><title>Blog GSoC project¬†: Common API for large molecular database, RADIS.</title><link>http://openastronomy.org/Universe_OA/posts/2023/05/20230508_1207_menasrac/</link><dc:creator>Racim MENASRIA</dc:creator><description>&lt;h4&gt;Blog GSoC project¬†: Common API for large molecular database, RADIS.&lt;/h4&gt;&lt;p&gt;Hello, I‚Äôm Racim MENASRIA a French engineering student at CentraleSupelec. I m glad to take part in the 2023 GSoC programm to contribute to Radis, a fast line-by-line code for high-resolution infrared molecular spectra.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/200/0*GIeb_J5QTLrhtfNj"&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/250/0*bNLY4YMhDxf2yxek"&gt;&lt;/figure&gt;&lt;p&gt;This blog will be used to post my results, remarks, difficulties or annything I consider useful to document my¬†work.&lt;/p&gt;
&lt;p&gt;I‚Äôm looking forward to stard contributing¬†:)&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=10c7a1c786e4" width="1"&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2023/05/20230508_1207_menasrac/</guid><pubDate>Mon, 08 May 2023 11:07:08 GMT</pubDate></item><item><title>Final Evaluation - A time to look back.</title><link>http://openastronomy.org/Universe_OA/posts/2022/09/20220912_0000_tranhuunhathuy/</link><dc:creator>TranHuuNhatHuy</dc:creator><description>&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/236320199c2c7323f80233362c6a584c/71b12/logoOA.png" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;!-- TEASER_END --&gt;
&lt;img alt="logo_OpenAstronomy" class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/236320199c2c7323f80233362c6a584c/f058b/logoOA.png" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="logo_OpenAstronomy"&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1. What I have done in OpenAstronomy and in RADIS&lt;/h4&gt;
&lt;p&gt;Throughout 3 months with RADIS, I have successfully developed a new fitting module for spectrum fitting purposes. RADIS has its own fitting feature, as shown in &lt;a href="https://radis.readthedocs.io/en/latest/auto_examples/plot_1T_fit.html#sphx-glr-auto-examples-plot-1t-fit-py"&gt;1-temperature fit example&lt;/a&gt;, where you have to manually create the spectrum model, input the experimental spectrum and other ground-truths into numerous RADIS native functions, as well as adjust the fitting pipeline yourself.&lt;/p&gt;
&lt;p&gt;Now with the new fitting module released, all you have to do is to prepare a &lt;code class="language-text"&gt;.spec&lt;/code&gt; file containing your experimental spectrum, fill some JSON forms describing the ground-truth conditions just like how you fill your medical checkup paper, call the function &lt;a href="https://radis.readthedocs.io/en/latest/source/radis.tools.new_fitting.html#radis.tools.new_fitting.fit_spectrum"&gt;&lt;code class="language-text"&gt;fit_spectrum()&lt;/code&gt;&lt;/a&gt; and let it do all the work! If you are not satisfied with the result, you can simply adjust the parameters in your JSON, such as &lt;code class="language-text"&gt;slit&lt;/code&gt; and &lt;code class="language-text"&gt;path_length&lt;/code&gt;, then recall the function again, until the results are satisfied.&lt;/p&gt;
&lt;p&gt;This is way easier and more convenient than dwelling into RADIS documentation to find out and learn how to use the current example, especially for new RADIS users. Various &lt;a href="https://github.com/radis/radis/pull/522#issue-1365475821"&gt;benchmarking efforts&lt;/a&gt; have shown that this new fitting module has performance advantages over the old version. This new fitting module aims to provide an end-to-end fitting experience, with minimum amount of RADIS knowledge needed.&lt;/p&gt;
&lt;p&gt;You can see an overview of my project here: &lt;a href="https://github.com/radis/radis/projects/6"&gt;https://github.com/radis/radis/projects/6&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;2. GSoC, RADIS and a learning curve that has been fulfilled&lt;/h4&gt;
&lt;p&gt;Throughout my GSoC journey with RADIS and working as a contributor, I really enjoyed all the experience of developing and contributing a meaningful improvement to a grand community-based project. Furthermore, I used to be a Computer Science majored student back in Vietnam, but after coming to Japan, I have been learning engineering for more than 2 years, enough for me to miss the old time coding projects and grinding hackathons, the days when I was truly a ‚ÄúCS student‚Äù. GSoC truly granted me a precious chance to rekindle the interest I have long lost, with wonderous opportunities to learn from prestigious mentors, and a huge boost for my background to get back to the run.&lt;/p&gt;
&lt;p&gt;In addition, one of the most satisfying moments in this GSoC, is when I finally nailed a bug or issue after days (or even weeks, trust me) of debugging, using the last brain cell to figure out what is the reason. The longer the suffering, the greater the hype that comes afterward. I guess we as developers all share this kind of experience often, but for a guy who starts coding again after a long time like, the ecstasy is at least three-fold.&lt;/p&gt;
&lt;p&gt;Furthermore, I don‚Äôt know what other open-source projects are, but RADIS is an extremely well-developed one. They have code coverage, pre-commit check, automatic documentation, and an extensive library of well-structured classes and methods for multiple purposes. This is a level of professional development I have never seen before, and I am extremely eager to learn all of this, not only within the GSoC, but also for a much longer time. This project also helped me to gain significant knowledge and experience&lt;/p&gt;
&lt;p&gt;So, to sum up, I really enjoyed this GSoC, especially with RADIS mentors and community. Thank you so much, GSoC and RADIS, for all of these wonderous experiences.&lt;/p&gt;
&lt;h4&gt;3. Of course, there were hard times, but hey, ‚ÄúHard times come again no more‚Äù&lt;/h4&gt;
&lt;p&gt;I believe the most challenging part of my GSoC 2022 experience, is during the development of my project itself. My project is ‚ÄúSpectrum Fitting Improvement‚Äù, in which I will implement a brand-new fitting method that uses a different module than the original method‚Äôs, and there are several challenges that I only discovered after joining the project.&lt;/p&gt;
&lt;p&gt;Firstly, the fitting process itself is totally a black box, where I implemented a spectrum, along with its ground-truth parameters, and hopefully the result comes as I expect. In the early days, there were weeks when I could not understand why the result went bad. The reasons could be faulty ground-truth data (original ground-truth parameters are incorrect), or the spectrum itself (mistakes during spectral variable extraction), a code bug, or even from the RADIS limitation itself (currently RADIS only uses air broadening coefficients, which is not suitable for experiments in other gases). All of these costed me huge time and efforts just trying to figure out the culprit, and those were the most anxious times.&lt;/p&gt;
&lt;p&gt;Secondly, there are several problems and bugs, or required implementations that can only be discovered during the last weeks of this GSoC, which makes these time tough and sour for me.&lt;/p&gt;
&lt;p&gt;Finally, my laptop was abruptly broken beyond repair during the middle of second phase, in which I had to wait for one week before the new laptop arrived and I could continue my work. Truly the darkest, most desperate days back then.&lt;/p&gt;
&lt;p&gt;Gradually the learning curve is flattened, but still, there were tough times. Thanks to GSoC, I could experience what would happen in a real project, where you have to anticipate and be ready to deal with all possible accidents and troubles, while keeping on a tight schedule. These will be precious experience for me and my career ahead.&lt;/p&gt;
&lt;h4&gt;4. A little tribute to my mentors&lt;/h4&gt;
&lt;p&gt;Firstly, I would like to say, thank you so much, my mentors - Mr. Erwan, Mr. Minou, Anand, Gagan, as well as other unofficial mentors such as Mr. Corentin - for all the time and efforts you have put through to guide us ‚Äì some random annoying students always trying to bother you with questions throughout 4 months.&lt;/p&gt;
&lt;p&gt;You helped us a lot in understanding the RADIS codebase and overall structure, as well as various skills in developing a grand-scaled project like RADIS. Throughout this GSoC, I had opportunity to familiarize with code coverage, pre-commit check and linting, automatic documentation such as readthedocs, a bunch of GitHub tips, and most important, a sheer confidence of open-source project contributing, by jumping into the source code itself, understanding it slow and steady, then finally pushing commits. Before this April, all of these were very scary for me. But now, as I look back, they are just breezes to me. Now I can truly understand and feel the scope of GSoC ‚Äì to encourage students to contribute to open-source projects. Thanks to you, this is a huge success to me.&lt;/p&gt;
&lt;p&gt;All of these could not be done without you entrusting us from the very beginning of selection process. From the very moment of you accepting us, we are here today, wrapping up what we have learned, finishing our projects, and carving our names into the list of RADIS contributors. These will be precious experience for me and my career ahead.&lt;/p&gt;
&lt;h4&gt;5. And finally, to someone reading this&lt;/h4&gt;
&lt;p&gt;Ayyo, to whoever reading this,&lt;/p&gt;
&lt;p&gt;I believe that you must be some next year‚Äôs GSoC applicants sneaking around and patiently preparing for the upcoming turn. If you are reading this, then firstly I would like to say thank you for reading all the way here.&lt;/p&gt;
&lt;p&gt;I have so many things to share you about all the experiences I had during this GSoC, about every moment in all aspects during these 3 months. But I‚Äôm afraid I might accidentally spoil your fun in near future, so I will only give some necessary advice, hope they might help you enjoy better in the next GSoC.&lt;/p&gt;
&lt;p&gt;Firstly, the actual time required to complete the project always LONGER than the initially planned time, so try your best to finish everything as soon as possible.&lt;/p&gt;
&lt;p&gt;Secondly, there might be times when you confront an extremely hard issue which takes you A LOT of time and you still cannot deal with it. When that time comes, explain to your mentors, and find a way, instead of gazing on the screen trying to solve it singlehandedly while wasting 1-2 weeks for that, like I did.&lt;/p&gt;
&lt;p&gt;This is also relevant to the above advice but, if you find yourself scared to tell your mentors about a challenge you are facing, please do not be afraid and just tell them. I used to be extremely afraid of asking my mentors because sometimes they were deadly serious (in a professional way), and thus I forced myself to solve an impossible task for 2 weeks before finally reaching out to them. Please do not be afraid and share with them anything, if you want to find a solution, if you want to change the current objectives, or whatever. Just ask!&lt;/p&gt;
&lt;p&gt;And finally, try to enjoy GSoC, I meant, every moment of it. It worths. Really.&lt;/p&gt;
&lt;p&gt;Good luck to become a GSoC member and successfully carve your name among contributors!&lt;/p&gt;
&lt;p&gt;September 12, 2022
Tran Huu Nhat Huy&lt;/p&gt;
&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/4d7ee6f3d3a81c95e441a7cc5dcadb98/ac99c/me.jpg" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;img alt="Me, among the peaks of Shizuoka, Japan." class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/4d7ee6f3d3a81c95e441a7cc5dcadb98/828fb/me.jpg" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="Me, among the peaks of Shizuoka, Japan."&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/09/20220912_0000_tranhuunhathuy/</guid><pubDate>Sun, 11 Sep 2022 23:00:00 GMT</pubDate></item><item><title>Week 12 - Final implementation into RADIS, along with a plethora of illustrative examples.</title><link>http://openastronomy.org/Universe_OA/posts/2022/09/20220905_0000_tranhuunhathuy/</link><dc:creator>TranHuuNhatHuy</dc:creator><description>&lt;h4&gt;1. Implementation of modules into RADIS&lt;/h4&gt;
&lt;p&gt;Finally, after being approved by Mr. Erwan, I can implement all of my modules, developed separately in my repo &lt;a href="https://github.com/TranHuuNhatHuy/RADIS-Spectrum-Fitting-Benchmark"&gt;RADIS-Spectrum-Fitting-Benchmark&lt;/a&gt;, into RADIS codebase. The implementation features &lt;a href="https://github.com/radis/radis/blob/develop/radis/tools/new_fitting.py"&gt;&lt;code class="language-text"&gt;new_fitting.py&lt;/code&gt;&lt;/a&gt;, the new fitting module that stores all the fitting functions and associated models, whose performance confirmed after a bunch of user-testing cases.&lt;/p&gt;
&lt;h4&gt;2. Accompanied illustrative examples&lt;/h4&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;They are gallery examples that are added into &lt;code class="language-text"&gt;radis/examples&lt;/code&gt;, serving as illustrative scripts for my new fitting module:&lt;/p&gt;
&lt;h5&gt;(i) &lt;code class="language-text"&gt;plot_newfitting_Tgas.py&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;The most basic example of how to use new fitting module, including the formats and so on.&lt;/p&gt;
&lt;h5&gt;(ii) &lt;code class="language-text"&gt;plot_newfitting_Trot-Tvib-molfrac.py&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;The real-life fitting case provided by Mr. Corentin, featuring non-LTE CO spectrum in which we will fit &lt;code class="language-text"&gt;Trot&lt;/code&gt;, &lt;code class="language-text"&gt;Tvib&lt;/code&gt; and &lt;code class="language-text"&gt;mole_fraction&lt;/code&gt;.&lt;/p&gt;
&lt;h5&gt;(iii) &lt;code class="language-text"&gt;plot_newfitting_Tgas-molfrac.py&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;Mr. Minou‚Äôs user-testing case of CO absorbance spectrum near 2011 cm-1. This case features spectrum extraction from a &lt;code class="language-text"&gt;.mat&lt;/code&gt; MATLAB file. Originally, this file was 1.2 MB, quite large to be added to RADIS. Thus, I removed all fields unnecessary for spectrum generation, and now it only has around 400 kB left.&lt;/p&gt;
&lt;h5&gt;(iv) &lt;code class="language-text"&gt;plot_newfitting_comparison_oldnew.py&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;Performance comparison example between &lt;a href="https://radis.readthedocs.io/en/latest/auto_examples/plot_1T_fit.html#sphx-glr-auto-examples-plot-1t-fit-py"&gt;current 1-temperature fitting&lt;/a&gt; and my new fitting module, under exactly the same ground-truths and settings. The benchmark result shows that, under exactly the same conditions, the new best fitted value differ 0.45% from the old one (1464.1 K from the old 1457.5 K). New fitting module requires half as many iterations as the old one and hence faster, with much smaller residual. In detail:&lt;/p&gt;
&lt;div class="gatsby-highlight"&gt;&lt;pre class="language-text"&gt;&lt;code class="language-text"&gt;====================  PERFORMANCE COMPARISON BETWEEN 2 FITTING METHODS  ====================

1. LAST RESIDUAL

- Old 1T fitting example:       0.002730027027336094
- New fitting module:           0.0005174179496843629

2. NUMBER OF FITTING LOOPS

- Old 1T fitting example:       32 loops
- New fitting module:           16 loops

3. TOTAL TIME TAKEN (s)

- Old 1T fitting example:       4.881942987442017 s
- New fitting module:           2.7344970703125 s

==========================================================================================&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I‚Äôm not sure this superiority will persist in all cases, but even so, I believe the value of my module still lies in its practical and easy to use/apply.&lt;/p&gt;
&lt;h5&gt;(v) &lt;code class="language-text"&gt;plot_newfitting_comparison_methods.py&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;A benchmarking example which compares performance between different &lt;a href="https://lmfit.github.io/lmfit-py/fitting.html#choosing-different-fitting-methods"&gt;LMFIT fitting algorithms&lt;/a&gt;. It measures their last residual (for accuracy evaluation) and number of iterations (for robustness evaluation). The benchmark result shows that, under exactly the same conditions, &lt;code class="language-text"&gt;leastsq&lt;/code&gt; and &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; work best, with &lt;code class="language-text"&gt;leastsq&lt;/code&gt; good at accuracy, while &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; good at speed (and theoretically, memory requirement). Thus, I set &lt;code class="language-text"&gt;leastsq&lt;/code&gt; as default method for the module, but also encourage users to switch to &lt;code class="language-text"&gt;lbfgsb&lt;/code&gt; in case things turn sour.&lt;/p&gt;
&lt;div class="gatsby-highlight"&gt;&lt;pre class="language-text"&gt;&lt;code class="language-text"&gt;======================== BENCHMARKING RESULT ========================

||           METHOD          ||          RESIDUAL         || LOOPS ||
||---------------------------||---------------------------||-------||
|| leastsq                   || 1.4739494411950239e-07    || 24    ||
|| least_squares             || 1.2170348021620847e-05    || 1     ||
|| differential_evolution    || 1.4739855740762716e-07    || 151   ||
|| brute                     || 1.2287258962300115e-06    || 20    ||
|| basinhopping              || 7.930954059631543e-06     || 151   ||
|| ampgo                     || 4.105104127826488e-07     || 151   ||
|| nelder                    || 1.4739942144030064e-07    || 30    ||
|| lbfgsb                    || 1.4739494411955646e-07    || 28    ||
|| powell                    || 1.473949441200994e-07     || 43    ||
|| cg                        || 1.4776331905574135e-07    || 30    ||
|| cobyla                    || 1.1524288718226295e-05    || 21    ||
|| bfgs                      || 1.4776331905574135e-07    || 30    ||
|| tnc                       || 1.4740393115424221e-07    || 28    ||
|| trust-constr              || 1.4739494411948182e-07    || 26    ||
|| slsqp                     || 1.2170348021620847e-05    || 2     ||
|| shgo                      || 1.0507694502308952e-05    || 5     ||
|| dual_annealing            || 1.5455930218501237e-05    || 151   ||
||---------------------------||---------------------------||-------||&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="gatsby-resp-image-wrapper" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;a class="gatsby-resp-image-link" href="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/dc95cb63a4457b8bb0d3d58fca7b8bbe/2bf90/method_compare_result.png" rel="noopener" style="display: block;" target="_blank"&gt;
&lt;span class="gatsby-resp-image-background-image" style="display: block;"&gt;&lt;/span&gt;
&lt;img alt="Method benchmarking result." class="gatsby-resp-image-image" src="https://gsoc2022tranhuunhathuy.gatsbyjs.io/static/dc95cb63a4457b8bb0d3d58fca7b8bbe/f058b/method_compare_result.png" style="width: 100%; height: 100%; margin: 0; vertical-align: middle;" title="Method benchmarking result."&gt;
&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/09/20220905_0000_tranhuunhathuy/</guid><pubDate>Sun, 04 Sep 2022 23:00:00 GMT</pubDate></item><item><title>Final Blog</title><link>http://openastronomy.org/Universe_OA/posts/2022/09/20220903_0000_arunavabasu-03/</link><dc:creator>arunavabasu-03</dc:creator><description>&lt;p&gt;Final Evaluation In this phase , i am preety much focusing to add the test files for frontend and backend and also setup the pipeline to run‚Ä¶&lt;/p&gt;
&lt;div style="margin-top: 50px; font-style: italic;"&gt;&lt;strong&gt;&lt;a href="https://gsoc.arunavabasu.com/12/"&gt;Keep reading&lt;/a&gt;.&lt;/strong&gt;&lt;/div&gt;&lt;br&gt; &lt;br&gt;
&lt;!-- TEASER_END --&gt;</description><category>radis</category><guid>http://openastronomy.org/Universe_OA/posts/2022/09/20220903_0000_arunavabasu-03/</guid><pubDate>Fri, 02 Sep 2022 23:00:00 GMT</pubDate></item></channel></rss>