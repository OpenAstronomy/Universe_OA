<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Universe OpenAstronomy (Posts by Kris Stern)</title><link>http://openastronomy.org/Universe_OA/</link><description></description><atom:link href="http://openastronomy.org/Universe_OA/authors/kris-stern.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Wed, 05 Aug 2020 01:50:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>GSoC 2020: glue-solar project 2.2</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200726_1213_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;The end of the 2nd Coding Period of this year’s Google Summer of Code has finally arrived. I cannot help but noticed the many things I have learned/built over the past two months for both the &lt;a href="http://glueviz.org/"&gt;glue&lt;/a&gt; Graphical User Interface (GUI), as well for its solar physics plugin glue-solar. One of the tricks I have learned is writing up tests for the GUI programming I have done in the process, which is using Qt for Python to port the entire &lt;a href="https://wiki.qt.io/PySide"&gt;PySide&lt;/a&gt; module to Qt5. My main approach is quite simple: Imitate, modify, test. Since glue has a fairly well developed codebase, it is not hard to find sample code snippets within it for inspiration of new code to add. The GUI unit tests are no exception to this rule. And, I would like to use the opportunity to share the experience with more novice contributors to the software, so perhaps somehow someone else somewhere down the line will be able to benefit from this.&lt;/p&gt;
&lt;p&gt;The first and foremost concern we should have regarding any type of unit testing is what we should check for functionality-wise. Let me take some code I have just written over the past few days which adds NDData (a data structure native to Astropy) support to glue and enables the loading of various types of astronomical data more readily, such as the standard FITS files. As I have discussed with my mentors via the glue-solar IRC channel, we have observed that NDData is much like laser was back in the 1960’s (e.g. as &lt;a href="https://www.nytimes.com/1964/05/06/archives/developer-of-the-laser-calls-it-a-solution-seeking-a-problem.html"&gt;reported by NYTimes&lt;/a&gt; then) was a solution in search of a problem before its wider adoption by the astronomy community for LSST, DKIST and CCDProc data. Now we are in the process of integrating it into glue. The original conception of this, at least in principle, is to use the simple and fluid structure of NDData to help process for example FITS data. This is because there are no generic NDData files in existence at all. This is to facilitate the manipulation of not only the data component, but also its units, mask, uncertainty, and meta attributes, which are quite common in the handling of astronomical data (pun intended). With such a motivation in mind, we have added a nddata.py module to the glue/core/data_factories directory in a &lt;a href="https://github.com/glue-viz/glue/pull/2164"&gt;PR&lt;/a&gt; at glue. To complete the PR, it is standard practice to add tests where applicable, so we have added a testing module called test_nddata.py in the glue/core/data_factories/tests directory to not only serve as a routine, but also to test whether the code has been properly debugged, which caught all of the major known bugs I have inadvertently introduced to the codebase before testing.&lt;/p&gt;
&lt;p&gt;The GUI unit test I have written is as follows:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;iframe src="http://openastronomy.org/Universe_OA/posts/2020/07/20200726_1213_kakirastern/" width="0" height="0" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/ba8b2229df9cf1b5b160c70096612af9/href"&gt;https://medium.com/media/ba8b2229df9cf1b5b160c70096612af9/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;I have studied the other tests in the same glue/core/data_factories/tests carefully before I proceed to write the code, as I have observed that the most basic test to write is to test the data loader. Of course, official docs helped me greatly as well. As for the formatted NDData factory, that would be hard to test. I will need to consult with my mentors, before deciding on whether a separate unit test for that later.&lt;/p&gt;
&lt;p&gt;One takeaway I have come away with in the process is that sufficient time is needed before I could brainstorm and come up with a tangible plan to write unit tests for any established codebase, and that I should not rush through the process. This is a lesson that I will definitely keep in mind. There is no use going through the motion and not enjoying the process as I go along, not to mention the omissions that I would make otherwise without a well thought-out plan.&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=db0e0ef935b2" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200726_1213_kakirastern/</guid><pubDate>Sun, 26 Jul 2020 11:13:28 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 2.1</title><link>http://openastronomy.org/Universe_OA/posts/2020/07/20200712_2340_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;The second coding period is now officially halfway through. Since the end of the first coding period, I have been working on both the &lt;a href="https://github.com/glue-viz/glue/pull/2156"&gt;1D Profile viewer&lt;/a&gt; and &lt;a href="https://github.com/glue-viz/glue/pull/2161"&gt;WCS autolinking&lt;/a&gt;. Since much has been discussed about the 1D Profile viewer of glue and now that it is finally working, let me take the opportunity to talk about the wcs-autolinking PR.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem statement&lt;/strong&gt;: Originally the wcs-autolinking only worked for some cases, for example for the spatial axes but not for the temporal and wavelength axes in the scenario where the dimensions of the two wcs objects of the data cubes being matched up do not match. This is highly undesirable and needs generalizing while conforming to &lt;a href="https://github.com/astropy/astropy-APEs/blob/master/APE14.rst"&gt;APE 14&lt;/a&gt;, where the issue of a shared Python interface for World Coordinate Systems is discussed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The solution&lt;/strong&gt;: So we rewrote the code. Most of the celestial code has been retained, with some new additions to add linking for the other dimensions. The code rewritten is as follows:&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;pre&gt;# Case for when the axes don't exactly match up&lt;br&gt;
if not forwards or not backwards:&lt;/pre&gt;&lt;pre&gt;    # A generalized APE 14-compatible way&lt;br&gt;
# Handle also the extra-spatial axes such as those of the time and wavelength dimensions&lt;/pre&gt;&lt;pre&gt;    if not wcs1.has_celestial or not wcs2.has_celestial:&lt;br&gt;
raise IncompatibleWCS("Can't create WCS link between {0} and {1}".format(data1.label, data2.label))&lt;/pre&gt;&lt;pre&gt;    try:&lt;br&gt;
wcs1_celestial = wcs1.celestial&lt;br&gt;
wcs2_celestial = wcs2.celestial&lt;br&gt;
wcs1_celestial_axis_physical_types = wcs1.celestial.world_axis_physical_types&lt;br&gt;
wcs2_celestial_axis_physical_types = wcs2.celestial.world_axis_physical_types&lt;br&gt;
print('wcs1.celestial.world_axis_physical_types', wcs1_celestial_axis_physical_types)&lt;br&gt;
print('wcs2.celestial.world_axis_physical_types', wcs2_celestial_axis_physical_types)&lt;br&gt;
except Exception:&lt;br&gt;
raise IncompatibleWCS("Can't create WCS link between {0} and {1}".format(data1.label, data2.label))&lt;/pre&gt;&lt;pre&gt;    cids1 = data1.pixel_component_ids&lt;br&gt;
cids1_celestial = [cids1[wcs1.wcs.naxis - wcs1.wcs.lng - 1],&lt;br&gt;
cids1[wcs1.wcs.naxis - wcs1.wcs.lat - 1]]&lt;br&gt;
slicing_axes_celestial1 = [cids1_celestial[0].axis, cids1_celestial[1].axis]&lt;br&gt;
slicing_axes_celestial1 = sorted(slicing_axes_celestial1, key=str, reverse=False)&lt;br&gt;
print('slicing_axes_celestial1', slicing_axes_celestial1)&lt;/pre&gt;&lt;pre&gt;    if wcs1_celestial.wcs.lng &amp;gt; wcs1_celestial.wcs.lat:&lt;br&gt;
cids1_celestial = cids1_celestial[::-1]&lt;/pre&gt;&lt;pre&gt;    cids2 = data2.pixel_component_ids&lt;br&gt;
cids2_celestial = [cids2[wcs2.wcs.naxis - wcs2.wcs.lng - 1],&lt;br&gt;
cids2[wcs2.wcs.naxis - wcs2.wcs.lat - 1]]&lt;br&gt;
slicing_axes_celestial2 = [cids2_celestial[0].axis, cids2_celestial[1].axis]&lt;br&gt;
slicing_axes_celestial2 = sorted(slicing_axes_celestial2, key=str, reverse=False)&lt;br&gt;
print('slicing_axes_celestial2', slicing_axes_celestial2)&lt;/pre&gt;&lt;pre&gt;    if wcs2_celestial.wcs.lng &amp;gt; wcs2_celestial.wcs.lat:&lt;br&gt;
cids2_celestial = cids2_celestial[::-1]&lt;/pre&gt;&lt;pre&gt;    # Collect all apparently matching axes in two lists for the two wcs objects being linked up&lt;br&gt;
wcs1_sliced_physical_types = wcs1_celestial_axis_physical_types&lt;br&gt;
slicing_axes1 = slicing_axes_celestial1&lt;br&gt;
wcs2_sliced_physical_types = wcs2_celestial_axis_physical_types&lt;br&gt;
slicing_axes2 = slicing_axes_celestial2&lt;br&gt;
for i, physical_type1 in enumerate(wcs1.world_axis_physical_types):&lt;br&gt;
for j, physical_type2 in enumerate(wcs2.world_axis_physical_types):&lt;br&gt;
if physical_type1 == physical_type2:&lt;br&gt;
if physical_type1 not in wcs1_sliced_physical_types:&lt;br&gt;
slicing_axes1.append(wcs1.world_n_dim - i - 1)&lt;br&gt;
wcs1_sliced_physical_types.append(physical_type1)&lt;br&gt;
if physical_type2 not in wcs2_sliced_physical_types:&lt;br&gt;
slicing_axes2.append(wcs2.world_n_dim - j - 1)&lt;br&gt;
wcs2_sliced_physical_types.append(physical_type2)&lt;/pre&gt;&lt;pre&gt;    slicing_axes1 = sorted(slicing_axes1, key=str, reverse=True)&lt;br&gt;
slicing_axes2 = sorted(slicing_axes2, key=str, reverse=True)&lt;/pre&gt;&lt;pre&gt;    print('slicing_axes1', slicing_axes1)&lt;br&gt;
print('slicing_axes2', slicing_axes2)&lt;/pre&gt;&lt;pre&gt;    print('wcs1_sliced_physical_types', wcs1_sliced_physical_types)&lt;br&gt;
print('wcs2_sliced_physical_types', wcs2_sliced_physical_types)&lt;/pre&gt;&lt;pre&gt;    # Generate slices for the wcs slicing&lt;br&gt;
slices1 = (slice(None),) * wcs1.world_n_dim&lt;br&gt;
slices2 = (slice(None),) * wcs2.world_n_dim&lt;/pre&gt;&lt;pre&gt;    slices1 = sorted(list(slices1))&lt;br&gt;
slices2 = sorted(list(slices2))&lt;/pre&gt;&lt;pre&gt;    for i in range(wcs1.world_n_dim):&lt;br&gt;
if i in slicing_axes1:&lt;br&gt;
pass&lt;br&gt;
else:&lt;br&gt;
slices1[i] = 0&lt;/pre&gt;&lt;pre&gt;    for i in range(wcs2.world_n_dim):&lt;br&gt;
if i in slicing_axes2:&lt;br&gt;
pass&lt;br&gt;
else:&lt;br&gt;
slices2[i] = 0&lt;/pre&gt;&lt;pre&gt;    wcs1_sliced = wcs1[tuple(slices1)]&lt;br&gt;
wcs2_sliced = wcs2[tuple(slices2)]&lt;/pre&gt;&lt;pre&gt;    cids1 = data1.pixel_component_ids&lt;br&gt;
cids1_sliced = [cids1[x] for x in slicing_axes1]&lt;br&gt;
cids1_sliced = sorted(cids1_sliced, key=str, reverse=True)&lt;/pre&gt;&lt;pre&gt;    cids2 = data2.pixel_component_ids&lt;br&gt;
cids2_sliced = [cids2[x] for x in slicing_axes2]&lt;br&gt;
cids2_sliced = sorted(cids2_sliced, key=str, reverse=True)&lt;/pre&gt;&lt;pre&gt;    pixel_cids1, pixel_cids2, forwards, backwards = get_cids_and_functions(&lt;br&gt;
wcs1_sliced, wcs2_sliced, cids1_sliced, cids2_sliced)&lt;/pre&gt;&lt;pre&gt;    self._physical_types_1 = wcs1_sliced_physical_types&lt;br&gt;
self._physical_types_2 = wcs2_sliced_physical_types&lt;/pre&gt;&lt;pre&gt;    if pixel_cids1 is None:&lt;br&gt;
raise IncompatibleWCS("Can't create WCS link between {0} and {1}".format(data1.label, data2.label))&lt;/pre&gt;&lt;p&gt;After checking with the tests written previously the code was modified before it is confirmed with pytest that all CI tests are now passing.&lt;/p&gt;
&lt;p&gt;Now we can link up wcs axes of the same physical types of two data cubes having different dimensions with no problems, illustrated as follows:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Ffgo6t1M0ah9UcCyeLVdfg.png"&gt;&lt;/figure&gt;&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=620347ad3f8d" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/07/20200712_2340_kakirastern/</guid><pubDate>Sun, 12 Jul 2020 22:40:22 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 1.2</title><link>http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1911_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;It has been a month since GSoC’s coding period started early in June 2020. Much has happened since then in the glue-solar project, and to sum it up I have been pretty much spending all my GSoC time working on a WCSAxes-enabled version the 1D Profile viewer for extracting 1D spectrum from data cubes using the pixel extracted in a 2D Image viewer. To be honest it has been very effort-intensive, though not necessarily time-intensive as I have previously feared. But the journey has been fun given my very supportive and friendly project mentors. To the layman and non-specialist what I have related regarding the project details probably sounds esoteric, which it is. With this realization I will split this and remaining GSoC blog posts into two halves: one pertaining to my personal struggles, and the other pertaining to the technical aspect of the work carried out thus far, in that order, so that that latter part can be conveniently skipped over (but I do encourage you to do read both sections in tandem so get a better understanding of the project :-p) Anyway, let me begin…&lt;/p&gt;
&lt;h4&gt;Part 1: Personal struggles&lt;/h4&gt;&lt;p&gt;One personal “secret” I wish to reveal is that this is my last year as a PhD Candidate in Astrophysics at the University of Hong Kong (HKU). Not only that, since my Postgraduate Scholarship officially ran out in October 2019 and no other funding options are available, I have been holding down a job as a front-end developer for some parts of the weekdays to support my PhD studies. So far I have been trying to manage my time wisely and balancing my various duties and obligations as best as possible, but it has been a genuine struggle, especially in me trying to find enough time to sleep. To make matters worse I have a tendency to drift towards writing code than writing my thesis, though I am making progress in both. So I did hesitated to apply for GSoC for a 2nd time this year and was originally against the idea. But when I saw the project ideas available I changed my mind. Glue-solar is actually like a godsend for me; the project enabled me to not only further develop my self-discipline as a person, it also allowed me to learn from experts in the field working on open-source data visualization, and to grow from the experience. I thoroughly enjoyed interacted with my mentors, who have been very patient and helpful in offering me guidance (as well as friendship) throughout. If I have any advice I am allowed to offer anyone wanting to try out open-source software development through GSoC, and if GSoC does continue in the near future, I would recommend them to try out any of the OpenAstronomy projects. This is because OpenAstronomy is one (relatively) small but vibrant community of dedicated programmers, many of which scientists, that is welcoming to newcomers coming from a diverse background. And also, simply put, ASTRONOMY IS FUN! This is especially true for SunPy. I remember I started to contribute to open-source software as a relative novice with some bookish knowledge but not a lot of real-world experience back in around January 2019. My first contributions were to SunPy and Astropy. I remember I have read an article about how to get into GSoC in 2018 to learn about the program, though was not all that keen in getting into it at first. My first motivation to contribute was to give back to the community, because I had been using Python-based astronomy packages like Astropy for my PhD research. But at the urge of a mentor active in the Astropy community, I did apply. The GSoC project I worked on last year in 2019 was &lt;a href="https://summerofcode.withgoogle.com/archive/2019/projects/6094580905148416/"&gt;IRISpy&lt;/a&gt;, and my mentors were &lt;strong&gt;Dan Ryan&lt;/strong&gt; and &lt;strong&gt;Laura Hayes&lt;/strong&gt;. They were amazing as mentors, and were instrumental in my being able to complete the project successfully in the end of the program. I still miss my time spent with them on that project. IRISpy has officially changed its name to sunraster, which I was fortunate enough to help launch earlier this year in 2020. Basically when I was working on it as a GSoC project it was to provide additional functionalities for the analysis of observations from NASA’s Interface Region Imaging Spectrograph (IRIS) satellite which looks at UV emission from the solar chromosphere in particular. Now that scope has been extended to not just IRIS data, but data collected with similar instruments. This year I am using a lot of the code I have written for the IRISpy project for the current glue-solar project, which is kind of cool. As an icing to the cake, I get to work on data cubes for glue-solar, which is one of my favorite things in this world, a passion I have gained through my PhD research into integral field spectroscopy (IFS). For the present GSoC work I even get to work on &lt;strong&gt;4D data cubes (ones with an extra &lt;em&gt;time&lt;/em&gt; dimension)&lt;/strong&gt;, which has one more dimension than the IFS cubes I am so familiar with! So far it has been another incredible GSoC experience for me. All in all I have a feeling it will be a good one, and also a fruitful one.&lt;/p&gt;
&lt;h4&gt;Part 2: Technical aspect of progress made in glue-solar&lt;/h4&gt;&lt;p&gt;So we (me and my mentors) have ventured away from focusing on glue-solar and have entered the glue “proper” territory as we put more time and effort towards modifying the 1D Profile viewer. By this I mean we have begun work on glue instead of glue-solar as was the case as described in &lt;a href="https://medium.com/@krisastern/gsoc-2020-glue-solar-project-1-1-c2151e535e0c"&gt;my previous article&lt;/a&gt; where we have built a “SunPy Map” viewer. So I am well on my way to complete the task “modifying the existing glue 1D Profile viewer to provide sliders for extra dimensions (currently collapses)” soon, which is a significant part of the glue-solar project. Personally, I am really looking forward to working on the “adding support for pre-computed statistics in datasets / viewers” task, which I will surely make time to complete before end of August.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;Let me demonstrate how far we have come with the modification of the 1D Profile viewer. So ordinarily it is hard to get 4D data cubes with a time dimension. This can be fixed by stacking sequential (IRIS) raster scans/cubes. After firing up glue from the terminal by the magic command “glue”, and importing some if not all raster scans from the same observation using the IRIS OBS directory importer, and choosing to “Stack the sequential raster scans” , we see some data points appearing in the Data field of the GUI. This is illustrated by the sequence of images to follow:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5te3r5u7q5pxeWhiBv4x9Q.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 1.&lt;/strong&gt; Loading an multi-scan IRIS Observation and choosing to stack the sequential raster scans / cubes.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DvJ0gwjAKMjdGefNeggEpA.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 2.&lt;/strong&gt; Stacked datasets which are essentially 4D data cubes appear in the Data field of the glue-solar GUI.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*c1fcKBkCGbcibrc2nfU93w.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 3.&lt;/strong&gt; As per usual, choosing the 2D Viewer option will enable us to inspect the different sides of the N-dimensional or ND data cube.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*A_dQDmastlGwmif17b7J2Q.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 4.&lt;/strong&gt; Choosing the right (N-1) slices for the slicing to obtain the 1D profile (which I have learned in a hard way is not always the same as a 1D spectrum coding-wise) using some pre-defined logic that warrants some explanation, though should be intuitive to some.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Qq70FXHsyObzBniXG35BOQ.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 5.&lt;/strong&gt; Using the 1D Profile tool, as opposed to the red 1D spectrum button in the 2D Image viewer, to generate the desired profile, which may or may not be a 1D spectrum.&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*FuXVHmy-MOFS-ELa6gFSUw.png"&gt;&lt;figcaption&gt;&lt;strong&gt;Figure 6.&lt;/strong&gt; Plotting of the uncollapsed version of the 1D profile by choosing the newly added “Slice” function which does nothing statistical to the data like the other functions such as “Maximum”, “Median”, and “Sum” that can be chosen as alternatives. (The default is “Maximum”).&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;As we can see in Figure 6, all 4 dimensions are represented in the 1D Profile viewer either as the x-axis or as a slider quantity. In this example, the x-axis is indeed wavelength (which yields a 1D spectrum by definition), the other dimensions are time, longitude (HPLN), and latitude (HPLT). Even though for now the sliders are still not yet functional and will need some tender loving care to make them work in tandem with the reference data as inherited or passed from the 2D Image viewer, which may take a few more days to complete, I believe this is truly a milestone in this GSoC project. If we can control the sliders to change the coordinate values, that would be a very useful tool in data exploration. I will spare the perhaps rather dry details regarding the reasoning through the whole thinking process that leads to this check point. However, I would like to explain the logic used in the slicing. What I have done is to introduced a SlicedData class, much like the existing IndexedData class that is used for pixel extraction with a tool my mentor &lt;strong&gt;Stuart Mumford&lt;/strong&gt; originally wrote for glue-solar (currently in a draft PR to be upstreamed to glue). First to pick a spatial coordinate, we choose in the 2D Image viewer the spatial axes for the image axes, selecting a point in the image shown on screen with the pixel selection tool, and then tweak the slider we would like its corresponding axis to be used as the x-axis in the 1D Profile viewer. Then we drag the same dataset to the viewing area and view using the 1D Profile viewer, in order to generate a profile for the slicing we have chosen. So this has been the work completed thus far. What is yet to be completed is to enable the manipulating of the 4D or higher dimensional data cube using the sliders for the same x-axis. So in the end regardless of the starting point, we could potentially use the 1D profile viewer to inspect the 4D or ND data cube in ways previously impossible before, at least to me.&lt;/p&gt;
&lt;p&gt;Again, I would like to thank my mentors for their guidance and support which enabled the progress I have made to happen. Much work will need to be done in order for the PRs to be polished up and merged later on in the summer. I really enjoy my glue-solar work for GSoC this summer. I hope you enjoyed reading this article as much as I had fun writing it too!&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=65ef40ba2b71" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/06/20200629_1911_kakirastern/</guid><pubDate>Mon, 29 Jun 2020 18:11:30 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 1.1</title><link>http://openastronomy.org/Universe_OA/posts/2020/06/20200614_0634_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;The official coding period of GSoC 2020 has begun on June 2nd (HKT) and the glue-solar work is currently underway according to plan as discussed with mentors &lt;strong&gt;Stuart Mumford&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;and&lt;strong&gt;&lt;em&gt; &lt;/em&gt;Nabil Freij &lt;/strong&gt;during the community bonding period that precedes the coding period. The tasks proposed that we would like to see implemented this summer include but not limited to the following:&lt;/p&gt;
&lt;p&gt;1. Modify the existing glue 1D Profile viewer to provide sliders for extra dimensions (currently collapses)&lt;br&gt;
2. Clean up UX / UI (icon) for the pixel extraction tool (perhaps also upstreaming from glue-solar to glue)&lt;br&gt;
&lt;!-- TEASER_END --&gt;
3. WCS info for derived datasets (i.e. raster + SJI time linking)&lt;br&gt;
4. Loaders for specific instruments: NDData (in glue), NDCube (for NDCube 2.0 with extra coords), SST, IRIS, EIS, DKIST (e.g. with asdf to glue) &lt;br&gt;
5. Add auto-linking to match wavelength and time dimensions in larger cubes (currently already works for Celestial dimensions)&lt;br&gt;
6. Enable image / Movie exports, both with axes and without axes via the matplotlib package&lt;br&gt;
7. Add support for pre-computed statistics in datasets / viewers&lt;/p&gt;
&lt;p&gt;The above, along with the accompanying documentation, are expected to be part of the deliverables of the GSoC project. So far a couple of pull requests (PRs) have been submitted to both the glue and glue-solar repositories (repos), with the most recent one being the one for updating the 1D Profile viewer to plot with wcsaxes instead, which can be accessed at glue-viz/glue's &lt;a href="https://github.com/glue-viz/glue/pull/2156"&gt;PR #2156&lt;/a&gt;. However, the CI problem encountered in this PR seems to be able to be fixed by upstreaming the pixel extraction tool which currently only resides in glue-solar. This will need to be discussed with my mentors as careful considerations such as one pertaining to timing are warranted.&lt;/p&gt;
&lt;p&gt;One of the first glue-solar PRs I have worked on are for adding an “open with SunPy Map” option to the “Import Data” tool. Part of this tool has been merged into glue-solar, while the other part is pending merge in glue. Basically if I load in an AIA map with its associated HMI map, like the sample one from SunPy, while choosing “SunPy Map” as opposed to the FITS format that gets detected by default, as shown in the Fig. 1:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*f1TZWTVe_Z7YqSwvPEGHXg.png"&gt;&lt;figcaption&gt;Fig. 1. Choosing “SunPy Map” to visualize SunPy maps with Glue.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;So if one plots the SunPy maps individually, one would get the what is shown in Fig. 2. This is basically the same as what one would get with FITS files as well, except for the colormaps.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-xqO_mMCzSNAAZAr6ipeJA.png"&gt;&lt;figcaption&gt;Fig. 2. Plotting “SunPy Map” objects individually&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The magic of our work is that now with the glue-solar plugin, we can overplot AIA map and its associated HMI map, as simply as dragging the HMI data from the Data section onto the AIA map 2D image already opened with the 2D Image viewer, as these are spatially linked by the plugin using some pixel-to-pixel transformation via WCS.&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*q0SWRNVOImWlLmpQ2k6_hQ.png"&gt;&lt;figcaption&gt;Fig. 3. Overplotting HMI data with AIA data with colormaps&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;So the subject of attention that has been the focus of my glue-solar work, or my favorite “toy”, over the last few weeks has been firstly a prototype for a “SunPy 1D Profile” tool which plots a 1D spectrum at a spatial position as picked out by the pixel extraction tool currently resides within glue-solar. To upstream the changes I have made to glue, and with the help of my mentors especially Stuart, we have started work on a PR to move such changes to the “1D Profile” in glue proper, using my “SunPy 1D Profile” work as a check and basis. If one loads in a raster cube using some IRIS level 2 data using the IRIS Spectrograph file type enabled by glue-solar, plots a slice of the data cube with the “2D Image” viewer, and then extracts a pixel position in the 2D image in the viewer (with the “HPLN” as the x-axis in lieu of the “wavelength” as the default option), one obtains a 1D profile upon hitting the spectrum icon in the 2D Image viewer panel. The result is as depicted in the collapsing “Fig. 4” image below:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WZdvkWlnqECjS66SIM9zbQ.png"&gt;&lt;figcaption&gt;Fig. 4. Plotting a 1D spectrum with wavelength as the x-axis and “Maximum” as the default function option.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;After which if one changes the “function” in the “Plot Options — 1D Profile” from the “maximum” to the newly added “slice” option in my PR, one would obtain a 1D spectrum without any collapsing as shown in the “Fig. 5” image below:&lt;/p&gt;
&lt;figure&gt;&lt;img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8ha0cEHSzxaY1zX-iSgMLw.png"&gt;&lt;figcaption&gt;Fig. 5. Visualizing a 1D spectrum at a pixel coordinate position after switching to the `Slice` function option that is non-collapsing.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;This non-collapsing 1D spectrum plotting facility is new to glue with the glue-solar plugin, and is currently still under heavy development.&lt;/p&gt;
&lt;p&gt;Overall it has been a great experience this second time around participating in GSoC at this early phase. The experience is especially positive given that I am engaged in some work that I could understand and really like. Previously I have been exposed to data cubes in my PhD studies in astrophysics, with the knowledge gained now comes in handy for my glue and glue-solar work. I look forward to contributing as much as possible to the project in the months to come during GSoC, and possibly beyond.&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=c2151e535e0c" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/06/20200614_0634_kakirastern/</guid><pubDate>Sun, 14 Jun 2020 05:34:50 GMT</pubDate></item><item><title>GSoC 2020: glue-solar project 0.1</title><link>http://openastronomy.org/Universe_OA/posts/2020/05/20200517_0228_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;div&gt;&lt;p&gt;I feel grateful for having been selected for the second time in a row to participate in &lt;strong&gt;GSoC&lt;/strong&gt; with the &lt;strong&gt;OpenAstronomy&lt;/strong&gt; organization with &lt;strong&gt;SunPy&lt;/strong&gt; as the sub-organization. My mentors this year are &lt;strong&gt;&lt;em&gt;Thomas Robitaille, Stuart Mumford, and Nabil Freij&lt;/em&gt;&lt;/strong&gt;, whom I have come to know within the astrophysics community over the past year or so and have come to respect. I am definitely looking forward to having a summer of serious fun with glue (or glueviz) in order to develop a plugin called glue-solar for use in solar physics data visualization. But to start I simply cannot resist delving more deeply into the glue-solar project. First off, here is a &lt;a href="https://summerofcode.withgoogle.com/projects/#5824429948403712"&gt;link&lt;/a&gt; to my project description over at GSoC’s official website.&lt;/p&gt;
&lt;p&gt;To introduce the glue-solar plugin, it is only natural to first introduce the glue package for which it operates on. As its official &lt;a href="http://glueviz.org/"&gt;website&lt;/a&gt; would suggest, glue is a package for multi-dimensional linked-data exploration. With glue, users can generate scatter plots, histograms, and both 2D and 3D images of their own data. The package emphasizes on the brushing and linking paradigm, where selections in any graph can propagate to all others. Moreover, glue uses the existing logical links between different data sets to overlay visualizations of different datasets, and to propagate the same selections across all other data sets. To clarify, these can be spatial and temporal links. These links are specified by the user, and are designed to be arbitrarily flexible. Finally, glue is written in Python, and built on top of its standard scientific libraries (e.g., Numpy, Matplotlib, Scipy), such that users can easily integrate their own python code for data input, cleaning, and analysis, enabling full scripting capability.&lt;/p&gt;
&lt;iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FqO3RQiRjWA4%3Ffeature%3Doembed&amp;amp;display_name=YouTube&amp;amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DqO3RQiRjWA4&amp;amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FqO3RQiRjWA4%2Fhqdefault.jpg&amp;amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;amp;type=text%2Fhtml&amp;amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"&gt;&lt;a href="https://medium.com/media/c5d030f496449b3a2e665643fa02682e/href"&gt;https://medium.com/media/c5d030f496449b3a2e665643fa02682e/href&lt;/a&gt;&lt;/iframe&gt;&lt;p&gt;Back to the glue-solar project, it is to provide a foundation for interactively exploring and quickly analyzing large datasets (100Gb or larger) in solar physics to be built in Python. This software will enable multi-instrument interactive visualisation as a &lt;strong&gt;plugin&lt;/strong&gt; of glue. While a fully featured GUI toolkit for solar data is not expected to be built in one summer due to time constraint, the goal is to provide the technical building blocks, but more importantly to demonstrate, and document, how this framework can be used by various instrument teams to build custom solutions for their solar data. Glue-solar, like glue is completely free for anyone to use and is open-source. Furthermore, glue-solar is a collaboration between glue and SunPy, hence its focus on solar physics.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;The official start date of this year’s GSoC is June 2nd, 2020, immediately after the current community bonding period. But work has already begun and we have already opened pull requests (or PRs) at both the glue and glue-solar repos to enable loading of basic SunPy maps such as AIA and HMI data so that they can be overplotted as different colormaps. As per usual, GSoC will last for about three months, until August 25th, 2020. This summer is surely going to be filled with many fun hours of coding for both glue and glue-solar for me. I am definitely looking forward to enjoying working on my last GSoC project this year, with my amazing mentors’ guidance.&lt;/p&gt;
&lt;img src="https://medium.com/_/stat?event=post.clientViewed&amp;amp;referrerSource=full_rss&amp;amp;postId=aae452de5e9" width="1" height="1"&gt;&lt;/div&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2020/05/20200517_0228_kakirastern/</guid><pubDate>Sun, 17 May 2020 01:28:15 GMT</pubDate></item><item><title>GSoC 2019: Project IRISpy 3.2 — Reaching the Goals</title><link>http://openastronomy.org/Universe_OA/posts/2019/08/20190818_1217_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;p&gt;GSoC 2019: Project IRISpy 3.2 — Reaching the GoalsIt is my pleasure to report that with my mentors’ assistance as well as my many hours of contributing to the sunpy/irispy GitHub repo, I have been able to reach all four goals original set out by the primary mentor Danny Ryan, which are as follows:Th &lt;a class="reference external" href="https://medium.com/@krisastern/gsoc-2019-project-irispy-3-2-reaching-the-goals-1ad1988ff9b5?source=rss-33703681b362------2"&gt;...READ MORE...&lt;/a&gt;&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2019/08/20190818_1217_kakirastern/</guid><pubDate>Sun, 18 Aug 2019 11:17:52 GMT</pubDate></item><item><title>GSoC 2019: Project IRISpy 3.1 — the Way Down</title><link>http://openastronomy.org/Universe_OA/posts/2019/08/20190804_1324_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;p&gt;GSoC 2019: Project IRISpy 3.1 — the Way DownGrateful to report that I have eventually solved the issues encountered as stated in blog post 2.2 in the series for my GSoC project… and most important of all with my mentors’ blessings I have successfully passed the 2nd coding phase. Moreover, I am delig &lt;a class="reference external" href="https://medium.com/@krisastern/gsoc-2019-project-irispy-3-1-the-way-down-ea622f00aaa6?source=rss-33703681b362------2"&gt;...READ MORE...&lt;/a&gt;&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2019/08/20190804_1324_kakirastern/</guid><pubDate>Sun, 04 Aug 2019 12:24:48 GMT</pubDate></item><item><title>GSoC 2019: Project IRISpy 2.2 — The final hurdle</title><link>http://openastronomy.org/Universe_OA/posts/2019/07/20190721_1109_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;p&gt;GSoC 2019: Project IRISpy 2.2 — The final hurdleTo follow up, the problem encountered as reported in edition 2.1 in this series has been resolved with the help of my very helpful and responsive mentors. But some lingering issues remain, which we suspect to be mostly indexing-related, as is apparent  &lt;a class="reference external" href="https://medium.com/@krisastern/gsoc-2019-project-irispy-2-2-the-final-hurdle-5214db169797?source=rss-33703681b362------2"&gt;...READ MORE...&lt;/a&gt;&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2019/07/20190721_1109_kakirastern/</guid><pubDate>Sun, 21 Jul 2019 10:09:57 GMT</pubDate></item><item><title>GSoC 2019: Project IRISpy 2.1 — Soldiering On</title><link>http://openastronomy.org/Universe_OA/posts/2019/07/20190707_1600_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;p&gt;GSoC 2019: Project IRISpy 2.1 — Soldiering OnPassed Phase 1 of GSoC. And I have just encountered my first roadblock in this project over the past few days, so now I am working hard on various approach to try and understand some IDL code snippets that does not translate well into Python without some  &lt;a class="reference external" href="https://medium.com/@krisastern/gsoc-2019-project-irispy-2-1-soldiering-on-c352ae9b2c5a?source=rss-33703681b362------2"&gt;...READ MORE...&lt;/a&gt;&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2019/07/20190707_1600_kakirastern/</guid><pubDate>Sun, 07 Jul 2019 15:00:35 GMT</pubDate></item><item><title>GSoC 2019: Project IRISpy 1.2 — Working up the chain to implement a new function</title><link>http://openastronomy.org/Universe_OA/posts/2019/06/20190623_1405_kakirastern/</link><dc:creator>Kris Stern</dc:creator><description>&lt;p&gt;GSoC 2019: Project IRISpy 1.2 — Working up the chain to implement a new functionFour weeks have passed since the commencement of the Coding Period on May 27th, 2019 (EST). Soon our 1st evaluation will come up, which in itself is an exciting time as we will be judged on whether we will be qualified t &lt;a class="reference external" href="https://medium.com/@krisastern/gsoc-2019-project-irispy-1-2-working-up-the-chain-to-implement-a-new-function-3c10d184f166?source=rss-33703681b362------2"&gt;...READ MORE...&lt;/a&gt;&lt;/p&gt;</description><category>SunPy</category><guid>http://openastronomy.org/Universe_OA/posts/2019/06/20190623_1405_kakirastern/</guid><pubDate>Sun, 23 Jun 2019 13:05:01 GMT</pubDate></item></channel></rss>